import cutter

from PySide2.QtCore import QObject, SIGNAL
from PySide2.QtWidgets import QAction, QTextEdit

data_dict = {"AAA": {"Instruction": "AAA", "Meaning": "ASCII adjust AL after addition", "Notes": "used with unpacked binary coded decimal", "Opcode": "0x37"}, "AAD": {"Instruction": "AAD", "Meaning": "ASCII adjust AX before division", "Notes": "8086/8088 datasheet documents only base 10 version of the AAD instruction (opcode 0xD5 0x0A), but any other base will work. Later Intel's documentation has the generic form too. NEC V20 and V30 (and possibly other NEC V-series CPUs) always use base 10, and ignore the argument, causing a number of incompatibilities", "Opcode": "0xD5"}, "AAM": {"Instruction": "AAM", "Meaning": "ASCII adjust AX after multiplication", "Notes": "Only base 10 version (Operand is 0xA) is documented, see notes for AAD", "Opcode": "0xD4"}, "AAS": {"Instruction": "AAS", "Meaning": "ASCII adjust AL after subtraction", "Notes": None, "Opcode": "0x3F"}, "ADC": {"Instruction": "ADC", "Meaning": "Add with carry", "Notes": "destination\u00a0:= destination + source + carry_flag", "Opcode": "0x10\u20260x15, 0x80/2\u20260x83/2"}, "ADD": {"Instruction": "ADD", "Meaning": "Add", "Notes": "(1) r/m += r/imm; (2) r += m/imm;", "Opcode": "0x00\u20260x05, 0x80/0\u20260x83/0"}, "AND": {"Instruction": "AND", "Meaning": "Logical AND", "Notes": "(1) r/m &= r/imm; (2) r &= m/imm;", "Opcode": "0x20\u20260x25, 0x80/4\u20260x83/4"}, "CALL": {"Instruction": "CALL", "Meaning": "Call procedure", "Notes": "push eip; eip points to the instruction directly after the call", "Opcode": "0x9A, 0xE8, 0xFF/2, 0xFF/3"}, "CBW": {"Instruction": "CBW", "Meaning": "Convert byte to word", "Notes": None, "Opcode": "0x98"}, "CLC": {"Instruction": "CLC", "Meaning": "Clear carry flag", "Notes": "CF = 0;", "Opcode": "0xF8"}, "CLD": {"Instruction": "CLD", "Meaning": "Clear direction flag", "Notes": "DF = 0;", "Opcode": "0xFC"}, "CLI": {"Instruction": "CLI", "Meaning": "Clear interrupt flag", "Notes": "IF = 0;", "Opcode": "0xFA"}, "CMC": {"Instruction": "CMC", "Meaning": "Complement carry flag", "Notes": None, "Opcode": "0xF5"}, "CMP": {"Instruction": "CMP", "Meaning": "Compare operands", "Notes": None, "Opcode": "0x38\u20260x3D, 0x80/7\u20260x83/7"}, "CMPSB": {"Instruction": "CMPSB", "Meaning": "Compare bytes in memory", "Notes": None, "Opcode": "0xA6"}, "CMPSW": {"Instruction": "CMPSW", "Meaning": "Compare words", "Notes": None, "Opcode": "0xA7"}, "CWD": {"Instruction": "CWD", "Meaning": "Convert word to doubleword", "Notes": None, "Opcode": "0x99"}, "DAA": {"Instruction": "DAA", "Meaning": "Decimal adjust AL after addition", "Notes": "(used with packed binary coded decimal)", "Opcode": "0x27"}, "DAS": {"Instruction": "DAS", "Meaning": "Decimal adjust AL after subtraction", "Notes": None, "Opcode": "0x2F"}, "DEC": {"Instruction": "DEC", "Meaning": "Decrement by 1", "Notes": None, "Opcode": "0x48\u20260x4F, 0xFE/1, 0xFF/1"}, "DIV": {"Instruction": "DIV", "Meaning": "Unsigned divide", "Notes": "DX:AX = DX:AX / r/m; resulting DX == remainder", "Opcode": "0xF6/6, 0xF7/6"}, "ESC": {"Instruction": "ESC", "Meaning": "Used with floating-point unit", "Notes": None, "Opcode": "0xD8..0xDF"}, "HLT": {"Instruction": "HLT", "Meaning": "Enter halt state", "Notes": None, "Opcode": "0xF4"}, "IDIV": {"Instruction": "IDIV", "Meaning": "Signed divide", "Notes": "DX:AX = DX:AX / r/m; resulting DX == remainder", "Opcode": "0xF6/7, 0xF7/7"}, "IMUL": {"Instruction": "IMUL", "Meaning": "Signed multiply", "Notes": "(1) DX:AX = AX * r/m; (2) AX = AL * r/m", "Opcode": "0x69, 0x6B (both since 80186), 0xF6/5, 0xF7/5, 0x0FAF (since 80386)"}, "IN": {"Instruction": "IN", "Meaning": "Input from port", "Notes": "(1) AL = port[imm]; (2) AL = port[DX]; (3) AX = port[imm]; (4) AX = port[DX];", "Opcode": "0xE4, 0xE5, 0xEC, 0xED"}, "INC": {"Instruction": "INC", "Meaning": "Increment by 1", "Notes": None, "Opcode": "0x40\u20260x47, 0xFE/0, 0xFF/0"}, "INT": {"Instruction": "INT", "Meaning": "Call to interrupt", "Notes": None, "Opcode": "0xCC, 0xCD"}, "INTO": {"Instruction": "INTO", "Meaning": "Call to interrupt if overflow", "Notes": None, "Opcode": "0xCE"}, "IRET": {"Instruction": "IRET", "Meaning": "Return from interrupt", "Notes": None, "Opcode": "0xCF"}, "Jcc": {"Instruction": "Jcc", "Meaning": "Jump if condition", "Notes": "(JA, JAE, JB, JBE, JC, JE, JG, JGE, JL, JLE, JNA, JNAE, JNB, JNBE, JNC, JNE, JNG, JNGE, JNL, JNLE, JNO, JNP, JNS, JNZ, JO, JP, JPE, JPO, JS, JZ)", "Opcode": "0x70\u20260x7F, 0x0F80\u20260x0F8F (since 80386)"}, "JCXZ": {"Instruction": "JCXZ", "Meaning": "Jump if CX is zero", "Notes": None, "Opcode": "0xE3"}, "JMP": {"Instruction": "JMP", "Meaning": "Jump", "Notes": None, "Opcode": "0xE9\u20260xEB, 0xFF/4, 0xFF/5"}, "LAHF": {"Instruction": "LAHF", "Meaning": "Load FLAGS into AH register", "Notes": None, "Opcode": "0x9F"}, "LDS": {"Instruction": "LDS", "Meaning": "Load pointer using DS", "Notes": None, "Opcode": "0xC5"}, "LEA": {"Instruction": "LEA", "Meaning": "Load Effective Address", "Notes": None, "Opcode": "0x8D"}, "LES": {"Instruction": "LES", "Meaning": "Load ES with pointer", "Notes": None, "Opcode": "0xC4"}, "LOCK": {"Instruction": "LOCK", "Meaning": "Assert BUS LOCK# signal", "Notes": "(for multiprocessing)", "Opcode": "0xF0"}, "LODSB": {"Instruction": "LODSB", "Meaning": "Load string byte", "Notes": "if (DF==0) AL = *SI++; else AL = *SI--;", "Opcode": "0xAC"}, "LODSW": {"Instruction": "LODSW", "Meaning": "Load string word", "Notes": "if (DF==0) AX = *SI++; else AX = *SI--;", "Opcode": "0xAD"}, "LOOP/LOOPx": {"Instruction": "LOOP/LOOPx", "Meaning": "Loop control", "Notes": "(LOOPE, LOOPNE, LOOPNZ, LOOPZ) if (x && --CX) goto lbl;", "Opcode": "0xE0\u20260xE2"}, "MOV": {"Instruction": "MOV", "Meaning": "Move", "Notes": "copies data from one location to another, (1) r/m = r; (2) r = r/m;", "Opcode": None}, "MOVSB": {"Instruction": "MOVSB", "Meaning": "Move byte from string to string", "Notes": "if (DF==0)   *(byte*)DI++ = *(byte*)SI++; else   *(byte*)DI-- = *(byte*)SI--;", "Opcode": "0xA4"}, "MOVSW": {"Instruction": "MOVSW", "Meaning": "Move word from string to string", "Notes": "if (DF==0)   *(word*)DI++ = *(word*)SI++; else   *(word*)DI-- = *(word*)SI--;", "Opcode": "0xA5"}, "MUL": {"Instruction": "MUL", "Meaning": "Unsigned multiply", "Notes": "(1) DX:AX = AX * r/m; (2) AX = AL * r/m;", "Opcode": "0xF6/4\u20260xF7/4"}, "NEG": {"Instruction": "NEG", "Meaning": "Two's complement negation", "Notes": "r/m *= -1;", "Opcode": "0xF6/3\u20260xF7/3"}, "NOP": {"Instruction": "NOP", "Meaning": "No operation", "Notes": "opcode equivalent to XCHG EAX, EAX", "Opcode": "0x90"}, "NOT": {"Instruction": "NOT", "Meaning": "Negate the operand, logical NOT", "Notes": "r/m ^= -1;", "Opcode": "0xF6/2\u20260xF7/2"}, "OR": {"Instruction": "OR", "Meaning": "Logical OR", "Notes": "(1) r/m |= r/imm; (2) r |= m/imm;", "Opcode": "0x08\u20260x0D, 0x80\u20260x83/1"}, "OUT": {"Instruction": "OUT", "Meaning": "Output to port", "Notes": "(1) port[imm] = AL; (2) port[DX] = AL; (3) port[imm] = AX; (4) port[DX] = AX;", "Opcode": "0xE6, 0xE7, 0xEE, 0xEF"}, "POP": {"Instruction": "POP", "Meaning": "Pop data from stack", "Notes": "r/m = *SP++; POP CS (opcode 0x0F) works only on 8086/8088. Later CPUs use 0x0F as a prefix for newer instructions.", "Opcode": "0x07, 0x0F(8086/8088 only), 0x17, 0x1F, 0x58\u20260x5F, 0x8F/0"}, "POPF": {"Instruction": "POPF", "Meaning": "Pop FLAGS register from stack", "Notes": "FLAGS = *SP++;", "Opcode": "0x9D"}, "PUSH": {"Instruction": "PUSH", "Meaning": "Push data onto stack", "Notes": "*--SP = r/m;", "Opcode": "0x06, 0x0E, 0x16, 0x1E, 0x50\u20260x57, 0x68, 0x6A (both since 80186), 0xFF/6"}, "PUSHF": {"Instruction": "PUSHF", "Meaning": "Push FLAGS onto stack", "Notes": "*--SP = FLAGS;", "Opcode": "0x9C"}, "RCL": {"Instruction": "RCL", "Meaning": "Rotate left (with carry)", "Notes": None, "Opcode": "0xC0\u20260xC1/2 (since 80186), 0xD0\u20260xD3/2"}, "RCR": {"Instruction": "RCR", "Meaning": "Rotate right (with carry)", "Notes": None, "Opcode": "0xC0\u20260xC1/3 (since 80186), 0xD0\u20260xD3/3"}, "REPxx": {"Instruction": "REPxx", "Meaning": "Repeat MOVS/STOS/CMPS/LODS/SCAS", "Notes": "(REP, REPE, REPNE, REPNZ, REPZ)", "Opcode": "0xF2, 0xF3"}, "RET": {"Instruction": "RET", "Meaning": "Return from procedure", "Notes": "Not a real instruction. The assembler will translate these to a RETN or a RETF depending on the memory model of the target system.", "Opcode": None}, "RETN": {"Instruction": "RETN", "Meaning": "Return from near procedure", "Notes": None, "Opcode": "0xC2, 0xC3"}, "RETF": {"Instruction": "RETF", "Meaning": "Return from far procedure", "Notes": None, "Opcode": "0xCA, 0xCB"}, "ROL": {"Instruction": "ROL", "Meaning": "Rotate left", "Notes": None, "Opcode": "0xC0\u20260xC1/0 (since 80186), 0xD0\u20260xD3/0"}, "ROR": {"Instruction": "ROR", "Meaning": "Rotate right", "Notes": None, "Opcode": "0xC0\u20260xC1/1 (since 80186), 0xD0\u20260xD3/1"}, "SAHF": {"Instruction": "SAHF", "Meaning": "Store AH into FLAGS", "Notes": None, "Opcode": "0x9E"}, "SAL": {"Instruction": "SAL", "Meaning": "Shift Arithmetically left (signed shift left)", "Notes": "(1) r/m <<= 1; (2) r/m <<= CL;", "Opcode": "0xC0\u20260xC1/4 (since 80186), 0xD0\u20260xD3/4"}, "SAR": {"Instruction": "SAR", "Meaning": "Shift Arithmetically right (signed shift right)", "Notes": "(1) (signed) r/m >>= 1; (2) (signed) r/m >>= CL;", "Opcode": "0xC0\u20260xC1/7 (since 80186), 0xD0\u20260xD3/7"}, "SBB": {"Instruction": "SBB", "Meaning": "Subtraction with borrow", "Notes": "alternative 1-byte encoding of SBB\u00a0AL,\u00a0AL is available via undocumented SALC instruction", "Opcode": "0x18\u20260x1D, 0x80\u20260x83/3"}, "SCASB": {"Instruction": "SCASB", "Meaning": "Compare byte string", "Notes": None, "Opcode": "0xAE"}, "SCASW": {"Instruction": "SCASW", "Meaning": "Compare word string", "Notes": None, "Opcode": "0xAF"}, "SHL": {"Instruction": "SHL", "Meaning": "Shift left (unsigned shift left)", "Notes": None, "Opcode": "0xC0\u20260xC1/4 (since 80186), 0xD0\u20260xD3/4"}, "SHR": {"Instruction": "SHR", "Meaning": "Shift right (unsigned shift right)", "Notes": None, "Opcode": "0xC0\u20260xC1/5 (since 80186), 0xD0\u20260xD3/5"}, "STC": {"Instruction": "STC", "Meaning": "Set carry flag", "Notes": "CF = 1;", "Opcode": "0xF9"}, "STD": {"Instruction": "STD", "Meaning": "Set direction flag", "Notes": "DF = 1;", "Opcode": "0xFD"}, "STI": {"Instruction": "STI", "Meaning": "Set interrupt flag", "Notes": "IF = 1;", "Opcode": "0xFB"}, "STOSB": {"Instruction": "STOSB", "Meaning": "Store byte in string", "Notes": "if (DF==0) *ES:DI++ = AL; else *ES:DI-- = AL;", "Opcode": "0xAA"}, "STOSW": {"Instruction": "STOSW", "Meaning": "Store word in string", "Notes": "if (DF==0) *ES:DI++ = AX; else *ES:DI-- = AX;", "Opcode": "0xAB"}, "SUB": {"Instruction": "SUB", "Meaning": "Subtraction", "Notes": "(1) r/m -= r/imm; (2) r -= m/imm;", "Opcode": "0x28\u20260x2D, 0x80\u20260x83/5"}, "TEST": {"Instruction": "TEST", "Meaning": "Logical compare (AND)", "Notes": "(1) r/m & r/imm; (2) r & m/imm;", "Opcode": "0x84, 0x84, 0xA8, 0xA9, 0xF6/0, 0xF7/0"}, "WAIT": {"Instruction": "WAIT", "Meaning": "Wait until not busy", "Notes": "Waits until BUSY# pin is inactive (used with floating-point unit)", "Opcode": "0x9B"}, "XCHG": {"Instruction": "XCHG", "Meaning": "Exchange data", "Notes": "r :=: r/m; A spinlock typically uses xchg as an atomic operation. (coma bug).", "Opcode": "0x86, 0x87, 0x91\u20260x97"}, "XLAT": {"Instruction": "XLAT", "Meaning": "Table look-up translation", "Notes": "behaves like MOV AL, [BX+AL]", "Opcode": "0xD7"}, "XOR": {"Instruction": "XOR", "Meaning": "Exclusive OR", "Notes": "(1) r/m ^= r/imm; (2) r ^= m/imm;", "Opcode": "0x30\u20260x35, 0x80\u20260x83/6"}, "BOUND": {"Instruction": "BOUND", "Meaning": "Check array index against bounds", "Notes": "raises software interrupt 5 if test fails"}, "ENTER": {"Instruction": "ENTER", "Meaning": "Enter stack frame", "Notes": "Modifies stack for entry to procedure for high level language. Takes two operands: the amount of storage to be allocated on the stack and the nesting level of the procedure."}, "INS": {"Instruction": "INS", "Meaning": "Input from port to string", "Notes": "equivalent toIN (E)AX, DXMOV ES:[(E)DI], (E)AX; adjust (E)DI according to operand size and DF"}, "LEAVE": {"Instruction": "LEAVE", "Meaning": "Leave stack frame", "Notes": "Releases the local stack storage created by the previous ENTER instruction."}, "OUTS": {"Instruction": "OUTS", "Meaning": "Output string to port", "Notes": "equivalent toMOV (E)AX, DS:[(E)SI]OUT DX, (E)AX; adjust (E)SI according to operand size and DF"}, "POPA": {"Instruction": "POPA", "Meaning": "Pop all general purpose registers from stack", "Notes": "equivalent toPOP DIPOP SIPOP BPPOP AX ;no POP SP here, all it does is ADD SP, 2 (since AX will be overwritten later)POP BXPOP DXPOP CXPOP AX"}, "PUSHA": {"Instruction": "PUSHA", "Meaning": "Push all general purpose registers onto stack", "Notes": "equivalent toPUSH AXPUSH CXPUSH DXPUSH BXPUSH SP ; The value stored is the initial SP valuePUSH BPPUSH SIPUSH DI"}, "PUSH immediate": {"Instruction": "PUSH immediate", "Meaning": "Push an immediate byte/word value onto the stack", "Notes": "equivalent toPUSH 12hPUSH 1200h"}, "IMUL immediate": {"Instruction": "IMUL immediate", "Meaning": "Signed multiplication of immediate byte/word value", "Notes": "equivalent toIMUL BX,12hIMUL DX,1200hIMUL CX, DX, 12hIMUL BX, SI, 1200hIMUL DI, word ptr [BX+SI], 12hIMUL SI, word ptr [BP-4], 1200h"}, "SHL/SHR/SAL/SAR/ROL/ROR/RCL/RCR immediate": {"Instruction": "SHL/SHR/SAL/SAR/ROL/ROR/RCL/RCR immediate", "Meaning": "Rotate/shift bits with an immediate value greater than 1", "Notes": "equivalent toROL AX,3SHR BL,3"}, "ARPL": {"Instruction": "ARPL", "Meaning": "Adjust RPL field of selector", "Notes": None}, "CLTS": {"Instruction": "CLTS", "Meaning": "Clear task-switched flag in register CR0", "Notes": None}, "LAR": {"Instruction": "LAR", "Meaning": "Load access rights byte", "Notes": None}, "LGDT": {"Instruction": "LGDT", "Meaning": "Load global descriptor table", "Notes": None}, "LIDT": {"Instruction": "LIDT", "Meaning": "Load interrupt descriptor table", "Notes": None}, "LLDT": {"Instruction": "LLDT", "Meaning": "Load local descriptor table", "Notes": None}, "LMSW": {"Instruction": "LMSW", "Meaning": "Load machine status word", "Notes": None}, "LOADALL": {"Instruction": "LOADALL", "Meaning": "Load all CPU registers, including internal ones such as GDT", "Notes": "Undocumented, 80286 and 80386 only"}, "LSL": {"Instruction": "LSL", "Meaning": "Load segment limit", "Notes": None}, "LTR": {"Instruction": "LTR", "Meaning": "Load task register", "Notes": None}, "SGDT": {"Instruction": "SGDT", "Meaning": "Store global descriptor table", "Notes": None}, "SIDT": {"Instruction": "SIDT", "Meaning": "Store interrupt descriptor table", "Notes": None}, "SLDT": {"Instruction": "SLDT", "Meaning": "Store local descriptor table", "Notes": None}, "SMSW": {"Instruction": "SMSW", "Meaning": "Store machine status word", "Notes": None}, "STR": {"Instruction": "STR", "Meaning": "Store task register", "Notes": None}, "VERR": {"Instruction": "VERR", "Meaning": "Verify a segment for reading", "Notes": None}, "VERW": {"Instruction": "VERW", "Meaning": "Verify a segment for writing", "Notes": None}, "BSF": {"Instruction": "BSF", "Meaning": "Bit scan forward", "Notes": None}, "BSR": {"Instruction": "BSR", "Meaning": "Bit scan reverse", "Notes": None}, "BT": {"Instruction": "BT", "Meaning": "Bit test", "Notes": None}, "BTC": {"Instruction": "BTC", "Meaning": "Bit test and complement", "Notes": None}, "BTR": {"Instruction": "BTR", "Meaning": "Bit test and reset", "Notes": None}, "BTS": {"Instruction": "BTS", "Meaning": "Bit test and set", "Notes": None}, "CDQ": {"Instruction": "CDQ", "Meaning": "Convert double-word to quad-word", "Notes": "Sign-extends EAX into EDX, forming the quad-word EDX:EAX. Since (I)DIV uses EDX:EAX as its input, CDQ must be called after setting EAX if EDX is not manually initialized (as in 64/32 division) before (I)DIV."}, "CMPSD": {"Instruction": "CMPSD", "Meaning": "Compare string double-word", "Notes": "Compares ES:[(E)DI] with DS:[(E)SI] and increments or decrements both (E)DI and (E)SI, depending on DF; can be prefixed with REP"}, "CWDE": {"Instruction": "CWDE", "Meaning": "Convert word to double-word", "Notes": "Unlike CWD, CWDE sign-extends AX to EAX instead of AX to DX:AX"}, "IBTS": {"Instruction": "IBTS", "Meaning": "Insert Bit String", "Notes": "discontinued with B1 step of 80386"}, "INSD": {"Instruction": "INSD", "Meaning": "Input from port to string double-word", "Notes": None}, "IRETx": {"Instruction": "IRETx", "Meaning": "Interrupt return; D suffix means 32-bit return, F suffix means do not generate epilogue code (i.e. LEAVE instruction)", "Notes": "Use IRETD rather than IRET in 32-bit situations"}, "JECXZ": {"Instruction": "JECXZ", "Meaning": "Jump if ECX is zero", "Notes": None}, "LFS, LGS": {"Instruction": "LFS, LGS", "Meaning": "Load far pointer", "Notes": None}, "LSS": {"Instruction": "LSS", "Meaning": "Load stack segment", "Notes": None}, "LODSD": {"Instruction": "LODSD", "Meaning": "Load string double-word", "Notes": "EAX = *ES:EDI\u00b1\u00b1; (\u00b1\u00b1 depends on DF, ES cannot be overridden); can be prefixed with REP"}, "LOOPW, LOOPccW": {"Instruction": "LOOPW, LOOPccW", "Meaning": "Loop, conditional loop", "Notes": "Same as LOOP, LOOPcc for earlier processors"}, "LOOPD, LOOPccD": {"Instruction": "LOOPD, LOOPccD", "Meaning": "Loop while equal", "Notes": "if (cc && --ECX) goto lbl;, cc = Z(ero), E(qual), NonZero, N(on)E(qual)"}, "MOV to/from CR/DR/TR": {"Instruction": "MOV to/from CR/DR/TR", "Meaning": "Move to/from special registers", "Notes": "CR=control registers, DR=debug registers, TR=test registers (up to 80486)"}, "MOVSD": {"Instruction": "MOVSD", "Meaning": "Move string double-word", "Notes": "*(dword*)ES:EDI\u00b1\u00b1 = (dword*)ESI\u00b1\u00b1; (\u00b1\u00b1 depends on DF); can be prefixed with REP"}, "MOVSX": {"Instruction": "MOVSX", "Meaning": "Move with sign-extension", "Notes": "(long)r = (signed char) r/m; and similar"}, "MOVZX": {"Instruction": "MOVZX", "Meaning": "Move with zero-extension", "Notes": "(long)r = (unsigned char) r/m; and similar"}, "OUTSD": {"Instruction": "OUTSD", "Meaning": "Output to port from string double-word", "Notes": " port[DX] = *(long*)ESI\u00b1\u00b1; (\u00b1\u00b1 depends on DF)"}, "POPAD": {"Instruction": "POPAD", "Meaning": "Pop all double-word (32-bit) registers from stack", "Notes": "Does not pop register ESP off of stack"}, "POPFD": {"Instruction": "POPFD", "Meaning": "Pop data into EFLAGS register", "Notes": None}, "PUSHAD": {"Instruction": "PUSHAD", "Meaning": "Push all double-word (32-bit) registers onto stack", "Notes": None}, "PUSHFD": {"Instruction": "PUSHFD", "Meaning": "Push EFLAGS register onto stack", "Notes": None}, "SCASD": {"Instruction": "SCASD", "Meaning": "Scan string data double-word", "Notes": "Compares ES:[(E)DI] with EAX and increments or decrements (E)DI, depending on DF; can be prefixed with REP"}, "SETcc": {"Instruction": "SETcc", "Meaning": "Set byte to one on condition, zero otherwise", "Notes": "(SETA, SETAE, SETB, SETBE, SETC, SETE, SETG, SETGE, SETL, SETLE, SETNA, SETNAE, SETNB, SETNBE, SETNC, SETNE, SETNG, SETNGE, SETNL, SETNLE, SETNO, SETNP, SETNS, SETNZ, SETO, SETP, SETPE, SETPO, SETS, SETZ)"}, "SHLD": {"Instruction": "SHLD", "Meaning": "Shift left double-word", "Notes": None}, "SHRD": {"Instruction": "SHRD", "Meaning": "Shift right double-word", "Notes": "r1 = r1>>CL \u2223 r2<<(32-CL); Instead of CL, immediate 1 can be used"}, "STOSD": {"Instruction": "STOSD", "Meaning": "Store string double-word", "Notes": "*ES:EDI\u00b1\u00b1 = EAX; (\u00b1\u00b1 depends on DF, ES cannot be overridden); can be prefixed with REP"}, "XBTS": {"Instruction": "XBTS", "Meaning": "Extract Bit String", "Notes": "discontinued with B1 step of 80386"}, "BSWAP": {"Instruction": "BSWAP", "Meaning": "Byte Swap", "Notes": "r = r<<24 | r<<8&0x00FF0000 | r>>8&0x0000FF00 | r>>24; Only defined for 32-bit registers. Usually used to change between little endian and big endian representations.  When used with 16-bit registers produces various different results on 486,[2] 586, and Bochs/QEMU.[3]"}, "CMPXCHG": {"Instruction": "CMPXCHG", "Meaning": "atomic CoMPare and eXCHanGe", "Notes": "See Compare-and-swap / on later 80386 as undocumented opcode available"}, "INVD": {"Instruction": "INVD", "Meaning": "Invalidate Internal Caches", "Notes": "Flush internal caches"}, "INVLPG": {"Instruction": "INVLPG", "Meaning": "Invalidate TLB Entry", "Notes": "Invalidate TLB Entry for page that contains data specified"}, "WBINVD": {"Instruction": "WBINVD", "Meaning": "Write Back and Invalidate Cache", "Notes": "Writes back all modified cache lines in the processor's internal cache to main memory and invalidates the internal caches."}, "XADD": {"Instruction": "XADD", "Meaning": "eXchange and ADD", "Notes": "Exchanges the first operand with the second operand, then loads the sum of the two values into the destination operand."}, "CPUID": {"Instruction": "CPUID", "Meaning": "CPU IDentification", "Notes": "Returns data regarding processor identification and features, and returns data to the EAX, EBX, ECX, and EDX registers. Instruction functions specified by the EAX register.[1] This was also added to later 80486 processors"}, "CMPXCHG8B": {"Instruction": "CMPXCHG8B", "Meaning": "CoMPare and eXCHanGe 8 bytes", "Notes": "Compare EDX:EAX with m64. If equal, set ZF and load ECX:EBX into m64. Else, clear ZF and load m64 into EDX:EAX."}, "RDMSR": {"Instruction": "RDMSR", "Meaning": "ReaD from Model-specific register", "Notes": "Load MSR specified by ECX into EDX:EAX"}, "RDTSC": {"Instruction": "RDTSC", "Meaning": "ReaD Time Stamp Counter", "Notes": "Returns the number of processor ticks since the processor being \"ONLINE\" (since the last power on of system)"}, "WRMSR": {"Instruction": "WRMSR", "Meaning": "WRite to Model-Specific Register", "Notes": "Write the value in EDX:EAX to MSR specified by ECX"}, "RSM[4]": {"Instruction": "RSM[4]", "Meaning": "Resume from System Management Mode", "Notes": "This was introduced by the i386SL and later and is also in the i486SL and later. Resumes from System Management Mode (SMM)"}, "RDPMC": {"Instruction": "RDPMC", "Meaning": "Read the PMC [Performance Monitoring Counter]", "Notes": "Specified in the ECX register into registers EDX:EAX"}, "SYSCALL": {"Instruction": "SYSCALL", "Meaning": None, "Notes": "functionally equivalent to SYSENTER"}, "SYSRET": {"Instruction": "SYSRET", "Meaning": None, "Notes": "functionally equivalent to SYSEXIT"}, "CMOVcc": {"Instruction": "CMOVcc", "Meaning": "Conditional move", "Notes": "(CMOVA, CMOVAE, CMOVB, CMOVBE, CMOVC, CMOVE, CMOVG, CMOVGE, CMOVL, CMOVLE, CMOVNA, CMOVNAE, CMOVNB, CMOVNBE, CMOVNC, CMOVNE, CMOVNG, CMOVNGE, CMOVNL, CMOVNLE, CMOVNO, CMOVNP, CMOVNS, CMOVNZ, CMOVO, CMOVP, CMOVPE, CMOVPO, CMOVS, CMOVZ)"}, "UD2": {"Instruction": "UD2", "Meaning": "Undefined Instruction", "Notes": "Generates an invalid opcode. This instruction is provided for software testing to explicitly generate an invalid opcode. The opcode for this instruction is reserved for this purpose."}, "SYSENTER": {"Instruction": "SYSENTER", "Meaning": "SYStem call ENTER", "Notes": "Sometimes called the Fast System Call instruction, this instruction was intended to increase the performance of operating system calls. Note that on the Pentium Pro, the CPUID instruction incorrectly reports these instructions as available."}, "SYSEXIT": {"Instruction": "SYSEXIT", "Meaning": "SYStem call EXIT", "Notes": None}, "MASKMOVQ mm1, mm2": {"Instruction": "MASKMOVQ mm1, mm2", "Opcode": "0F F7 /r", "Meaning": "Masked Move of Quadword", "Notes": "Selectively write bytes from mm1 to memory location using the byte mask in mm2"}, "MOVNTPS m128, xmm1": {"Instruction": "MOVNTPS m128, xmm1", "Opcode": "0F 2B /r", "Meaning": "Move Aligned Four Packed Single-FP Non Temporal", "Notes": "Move packed single-precision floating-point values from xmm1 to m128, minimizing pollution in the cache hierarchy."}, "MOVNTQ m64, mm": {"Instruction": "MOVNTQ m64, mm", "Opcode": "0F E7 /r", "Meaning": "Move Quadword Using Non-Temporal Hint", "Notes": None}, "NOP r/m16": {"Instruction": "NOP r/m16", "Opcode": "0F 1F /0", "Meaning": "Multi-byte no-operation instruction.", "Notes": None}, "PREFETCHT0": {"Instruction": "PREFETCHT0", "Opcode": "0F 18 /1", "Meaning": "Prefetch Data from Address", "Notes": "Prefetch into all cache levels"}, "PREFETCHT1": {"Instruction": "PREFETCHT1", "Opcode": "0F 18 /2", "Meaning": "Prefetch Data from Address", "Notes": "Prefetch into all cache levels EXCEPT[5][6] L1"}, "PREFETCHT2": {"Instruction": "PREFETCHT2", "Opcode": "0F 18 /3", "Meaning": "Prefetch Data from Address", "Notes": "Prefetch into all cache levels EXCEPT L1 and L2"}, "PREFETCHNTA": {"Instruction": "PREFETCHNTA", "Opcode": "0F 18 /0", "Meaning": "Prefetch Data from Address", "Notes": "Prefetch to non-temporal cache structure, minimizing cache pollution."}, "SFENCE": {"Instruction": "SFENCE", "Opcode": "0F AE F8", "Meaning": "Store Fence", "Notes": "Processor hint to make sure all store operations that took place prior to the SFENCE call are globally visible"}, "CLFLUSH m8": {"Instruction": "CLFLUSH m8", "Opcode": "0F AE /7", "Meaning": "Cache Line Flush", "Notes": "Invalidates the cache line that contains the linear address specified with the source operand from all levels of the processor cache hierarchy"}, "LFENCE": {"Instruction": "LFENCE", "Opcode": "0F AE E8", "Meaning": "Load Fence", "Notes": "Serializes load operations."}, "MFENCE": {"Instruction": "MFENCE", "Opcode": "0F AE F0", "Meaning": "Memory Fence", "Notes": "Performs a serializing operation on all load and store instructions that were issued prior the MFENCE instruction."}, "MOVNTI m32, r32": {"Instruction": "MOVNTI m32, r32", "Opcode": "0F C3 /r", "Meaning": "Move Doubleword Non-Temporal", "Notes": "Move doubleword from r32 to m32, minimizing pollution in the cache hierarchy."}, "PAUSE": {"Instruction": "PAUSE", "Opcode": "F3 90", "Meaning": "Spin Loop Hint", "Notes": "Provides a hint to the processor that the following code is a spin loop, for cacheability"}, "MONITOR EAX, ECX, EDX": {"Instruction": "MONITOR EAX, ECX, EDX", "Meaning": "Setup Monitor Address", "Notes": "Sets up a linear address range to be monitored by hardware and activates the monitor."}, "MWAIT EAX, ECX": {"Instruction": "MWAIT EAX, ECX", "Meaning": "Monitor Wait", "Notes": "Processor hint to stop instruction execution and enter an implementation-dependent optimized state until occurrence of a class of events."}, "CRC32 r32, r/m8": {"Instruction": "CRC32 r32, r/m8", "Opcode": "F2 0F 38 F0 /r", "Meaning": "Accumulate CRC32", "Notes": "Computes CRC value using the CRC-32C (Castagnoli) polynomial 0x11EDC6F41 (normal form 0x1EDC6F41). This is the polynomial used in iSCSI. In contrast to the more popular one used in Ethernet, its parity is even, and it can thus detect any error with an odd number of changed bits."}, "CDQE": {"Instruction": "CDQE", "Meaning": "Sign extend EAX into RAX", "Notes": None}, "CQO": {"Instruction": "CQO", "Meaning": "Sign extend RAX into RDX:RAX", "Notes": None}, "CMPSQ": {"Instruction": "CMPSQ", "Meaning": "CoMPare String Quadword", "Notes": None}, "CMPXCHG16B": {"Instruction": "CMPXCHG16B", "Meaning": "CoMPare and eXCHanGe 16 Bytes", "Notes": None}, "IRETQ": {"Instruction": "IRETQ", "Meaning": "64-bit Return from Interrupt", "Notes": None}, "JRCXZ": {"Instruction": "JRCXZ", "Meaning": "Jump if RCX is zero", "Notes": None}, "LODSQ": {"Instruction": "LODSQ", "Meaning": "LoaD String Quadword", "Notes": None}, "MOVSXD": {"Instruction": "MOVSXD", "Meaning": "MOV with Sign Extend 32-bit to 64-bit", "Notes": None}, "POPFQ": {"Instruction": "POPFQ", "Meaning": "POP RFLAGS Register", "Notes": None}, "PUSHFQ": {"Instruction": "PUSHFQ", "Meaning": "PUSH RFLAGS Register", "Notes": None}, "RDTSCP": {"Instruction": "RDTSCP", "Meaning": "ReaD Time Stamp Counter and Processor ID", "Notes": None}, "SCASQ": {"Instruction": "SCASQ", "Meaning": "SCAn String Quadword", "Notes": None}, "STOSQ": {"Instruction": "STOSQ", "Meaning": "STOre String Quadword", "Notes": None}, "SWAPGS": {"Instruction": "SWAPGS", "Meaning": "Exchange GS base with KernelGSBase MSR", "Notes": None}, "CLGI": {"Instruction": "CLGI", "Meaning": "Clear Global Interrupt Flag", "Notes": "Clears the GIF", "Opcode": "0x0F\u00a00x01\u00a00xDD"}, "INVLPGA": {"Instruction": "INVLPGA", "Meaning": "Invalidate TLB entry in a specified ASID", "Notes": "Invalidates the TLB mapping for the virtual page specified in RAX and the ASID specified in ECX.", "Opcode": "0x0F\u00a00x01\u00a00xDF"}, "MOV(CRn)": {"Instruction": "MOV(CRn)", "Meaning": "Move to or from control registers", "Notes": "Moves 32- or 64-bit contents to control register and vice versa.", "Opcode": "0x0F\u00a00x22 or 0x0F\u00a00x20"}, "MOV(DRn)": {"Instruction": "MOV(DRn)", "Meaning": "Move to or from debug registers", "Notes": "Moves 32- or 64-bit contents to control register and vice versa.", "Opcode": "0x0F\u00a00x21 or 0x0F\u00a00x23"}, "SKINIT": {"Instruction": "SKINIT", "Meaning": "Secure Init and Jump with Attestation", "Notes": "Verifiable startup of trusted software based on secure hash comparison", "Opcode": "0x0F\u00a00x01\u00a00xDE"}, "STGI": {"Instruction": "STGI", "Meaning": "Set Global Interrupt Flag", "Notes": "Sets the GIF.", "Opcode": "0x0F\u00a00x01\u00a00xDC"}, "VMLOAD": {"Instruction": "VMLOAD", "Meaning": "Load state From VMCB", "Notes": "Loads a subset of processor state from the VMCB specified by the physical address in the RAX register.", "Opcode": "0x0F\u00a00x01\u00a00xDA"}, "VMMCALL": {"Instruction": "VMMCALL", "Meaning": "Call VMM", "Notes": "Used exclusively to communicate with VMM", "Opcode": "0x0F\u00a00x01\u00a00xD9"}, "VMRUN": {"Instruction": "VMRUN", "Meaning": "Run virtual machine", "Notes": "Performs a switch to the guest OS.", "Opcode": "0x0F\u00a00x01\u00a00xD8"}, "VMSAVE": {"Instruction": "VMSAVE", "Meaning": "Save state To VMCB", "Notes": "Saves additional guest state to VMCB.", "Opcode": "0x0F\u00a00x01\u00a00xDB"}, "VMPTRLD": {"Instruction": "VMPTRLD", "Meaning": "Load Pointer to Virtual-Machine Control Structure", "Notes": "Loads the current VMCS pointer from memory.", "Opcode": "0x0F\u00a00xC7/6"}, "VMPTRST": {"Instruction": "VMPTRST", "Meaning": "Store Pointer to Virtual-Machine Control Structure", "Notes": "Stores the current-VMCS pointer into a specified memory address. The operand of this instruction is always 64 bits and is always in memory.", "Opcode": "0x0F\u00a00xC7/7"}, "VMCLEAR": {"Instruction": "VMCLEAR", "Meaning": "Clear Virtual-Machine Control Structure", "Notes": "Writes any cached data to the VMCS", "Opcode": "0x66\u00a00x0F\u00a00xC7/6"}, "VMREAD": {"Instruction": "VMREAD", "Meaning": "Read Field from Virtual-Machine Control Structure", "Notes": "Reads out a field in the VMCS", "Opcode": "0x0F\u00a00x78"}, "VMWRITE": {"Instruction": "VMWRITE", "Meaning": "Write Field to Virtual-Machine Control Structure", "Notes": "Modifies a field in the VMCS", "Opcode": "0x0F\u00a00x79"}, "VMCALL": {"Instruction": "VMCALL", "Meaning": "Call to VM Monitor", "Notes": "Calls VM Monitor function from Guest System", "Opcode": "0x0F\u00a00x01\u00a00xC1"}, "VMLAUNCH": {"Instruction": "VMLAUNCH", "Meaning": "Launch Virtual Machine", "Notes": "Launch virtual machine managed by current VMCS", "Opcode": "0x0F\u00a00x01\u00a00xC2"}, "VMRESUME": {"Instruction": "VMRESUME", "Meaning": "Resume Virtual Machine", "Notes": "Resume virtual machine managed by current VMCS", "Opcode": "0x0F\u00a00x01\u00a00xC3"}, "VMXOFF": {"Instruction": "VMXOFF", "Meaning": "Leave VMX Operation", "Notes": "Stops hardware supported virtualisation environment", "Opcode": "0x0F\u00a00x01\u00a00xC4"}, "VMXON": {"Instruction": "VMXON", "Meaning": "Enter VMX Operation", "Notes": "Enters hardware supported virtualisation environment", "Opcode": "0xF3\u00a00x0F\u00a00xC7/6"}, "F2XM1": {"Instruction": "F2XM1", "Meaning": "2x\u22121{\\displaystyle 2^{x}-1}", "Notes": "more precise than 2x{\\displaystyle 2^{x}} for x close to zero"}, "FABS": {"Instruction": "FABS", "Meaning": "Absolute value", "Notes": None}, "FADD": {"Instruction": "FADD", "Meaning": "Add", "Notes": None}, "FADDP": {"Instruction": "FADDP", "Meaning": "Add and pop", "Notes": None}, "FBLD": {"Instruction": "FBLD", "Meaning": "Load BCD", "Notes": None}, "FBSTP": {"Instruction": "FBSTP", "Meaning": "Store BCD and pop", "Notes": None}, "FCHS": {"Instruction": "FCHS", "Meaning": "Change sign", "Notes": None}, "FCLEX": {"Instruction": "FCLEX", "Meaning": "Clear exceptions", "Notes": None}, "FCOM": {"Instruction": "FCOM", "Meaning": "Compare", "Notes": None}, "FCOMP": {"Instruction": "FCOMP", "Meaning": "Compare and pop", "Notes": None}, "FCOMPP": {"Instruction": "FCOMPP", "Meaning": "Compare and pop twice", "Notes": None}, "FDECSTP": {"Instruction": "FDECSTP", "Meaning": "Decrement floating point stack pointer", "Notes": None}, "FDISI": {"Instruction": "FDISI", "Meaning": "Disable interrupts", "Notes": "8087 only, otherwise FNOP"}, "FDIV": {"Instruction": "FDIV", "Meaning": "Divide", "Notes": "Pentium FDIV bug"}, "FDIVP": {"Instruction": "FDIVP", "Meaning": "Divide and pop", "Notes": None}, "FDIVR": {"Instruction": "FDIVR", "Meaning": "Divide reversed", "Notes": None}, "FDIVRP": {"Instruction": "FDIVRP", "Meaning": "Divide reversed and pop", "Notes": None}, "FENI": {"Instruction": "FENI", "Meaning": "Enable interrupts", "Notes": "8087 only, otherwise FNOP"}, "FFREE": {"Instruction": "FFREE", "Meaning": "Free register", "Notes": None}, "FIADD": {"Instruction": "FIADD", "Meaning": "Integer add", "Notes": None}, "FICOM": {"Instruction": "FICOM", "Meaning": "Integer compare", "Notes": None}, "FICOMP": {"Instruction": "FICOMP", "Meaning": "Integer compare and pop", "Notes": None}, "FIDIV": {"Instruction": "FIDIV", "Meaning": "Integer divide", "Notes": None}, "FIDIVR": {"Instruction": "FIDIVR", "Meaning": "Integer divide reversed", "Notes": None}, "FILD": {"Instruction": "FILD", "Meaning": "Load integer", "Notes": None}, "FIMUL": {"Instruction": "FIMUL", "Meaning": "Integer multiply", "Notes": None}, "FINCSTP": {"Instruction": "FINCSTP", "Meaning": "Increment floating point stack pointer", "Notes": None}, "FINIT": {"Instruction": "FINIT", "Meaning": "Initialize floating point processor", "Notes": None}, "FIST": {"Instruction": "FIST", "Meaning": "Store integer", "Notes": None}, "FISTP": {"Instruction": "FISTP", "Meaning": "Store integer and pop", "Notes": None}, "FISUB": {"Instruction": "FISUB", "Meaning": "Integer subtract", "Notes": None}, "FISUBR": {"Instruction": "FISUBR", "Meaning": "Integer subtract reversed", "Notes": None}, "FLD": {"Instruction": "FLD", "Meaning": "Floating point load", "Notes": None}, "FLD1": {"Instruction": "FLD1", "Meaning": "Load 1.0 onto stack", "Notes": None}, "FLDCW": {"Instruction": "FLDCW", "Meaning": "Load control word", "Notes": None}, "FLDENV": {"Instruction": "FLDENV", "Meaning": "Load environment state", "Notes": None}, "FLDENVW": {"Instruction": "FLDENVW", "Meaning": "Load environment state, 16-bit", "Notes": None}, "FLDL2E": {"Instruction": "FLDL2E", "Meaning": "Load log2(e) onto stack", "Notes": None}, "FLDL2T": {"Instruction": "FLDL2T", "Meaning": "Load log2(10) onto stack", "Notes": None}, "FLDLG2": {"Instruction": "FLDLG2", "Meaning": "Load log10(2) onto stack", "Notes": None}, "FLDLN2": {"Instruction": "FLDLN2", "Meaning": "Load ln(2) onto stack", "Notes": None}, "FLDPI": {"Instruction": "FLDPI", "Meaning": "Load \u03c0 onto stack", "Notes": None}, "FLDZ": {"Instruction": "FLDZ", "Meaning": "Load 0.0 onto stack", "Notes": None}, "FMUL": {"Instruction": "FMUL", "Meaning": "Multiply", "Notes": None}, "FMULP": {"Instruction": "FMULP", "Meaning": "Multiply and pop", "Notes": None}, "FNCLEX": {"Instruction": "FNCLEX", "Meaning": "Clear exceptions, no wait", "Notes": None}, "FNDISI": {"Instruction": "FNDISI", "Meaning": "Disable interrupts, no wait", "Notes": "8087 only, otherwise FNOP"}, "FNENI": {"Instruction": "FNENI", "Meaning": "Enable interrupts, no wait", "Notes": "8087 only, otherwise FNOP"}, "FNINIT": {"Instruction": "FNINIT", "Meaning": "Initialize floating point processor, no wait", "Notes": None}, "FNOP": {"Instruction": "FNOP", "Meaning": "No operation", "Notes": None}, "FNSAVE": {"Instruction": "FNSAVE", "Meaning": "Save FPU state, no wait, 8-bit", "Notes": None}, "FNSAVEW": {"Instruction": "FNSAVEW", "Meaning": "Save FPU state, no wait, 16-bit", "Notes": None}, "FNSTCW": {"Instruction": "FNSTCW", "Meaning": "Store control word, no wait", "Notes": None}, "FNSTENV": {"Instruction": "FNSTENV", "Meaning": "Store FPU environment, no wait", "Notes": None}, "FNSTENVW": {"Instruction": "FNSTENVW", "Meaning": "Store FPU environment, no wait, 16-bit", "Notes": None}, "FNSTSW": {"Instruction": "FNSTSW", "Meaning": "Store status word, no wait", "Notes": None}, "FPATAN": {"Instruction": "FPATAN", "Meaning": "Partial arctangent", "Notes": None}, "FPREM": {"Instruction": "FPREM", "Meaning": "Partial remainder", "Notes": None}, "FPTAN": {"Instruction": "FPTAN", "Meaning": "Partial tangent", "Notes": None}, "FRNDINT": {"Instruction": "FRNDINT", "Meaning": "Round to integer", "Notes": None}, "FRSTOR": {"Instruction": "FRSTOR", "Meaning": "Restore saved state", "Notes": None}, "FRSTORW": {"Instruction": "FRSTORW", "Meaning": "Restore saved state", "Notes": "Perhaps not actually available in 8087"}, "FSAVE": {"Instruction": "FSAVE", "Meaning": "Save FPU state", "Notes": None}, "FSAVEW": {"Instruction": "FSAVEW", "Meaning": "Save FPU state, 16-bit", "Notes": None}, "FSCALE": {"Instruction": "FSCALE", "Meaning": "Scale by factor of 2", "Notes": None}, "FSQRT": {"Instruction": "FSQRT", "Meaning": "Square root", "Notes": None}, "FST": {"Instruction": "FST", "Meaning": "Floating point store", "Notes": None}, "FSTCW": {"Instruction": "FSTCW", "Meaning": "Store control word", "Notes": None}, "FSTENV": {"Instruction": "FSTENV", "Meaning": "Store FPU environment", "Notes": None}, "FSTENVW": {"Instruction": "FSTENVW", "Meaning": "Store FPU environment, 16-bit", "Notes": None}, "FSTP": {"Instruction": "FSTP", "Meaning": "Store and pop", "Notes": None}, "FSTSW": {"Instruction": "FSTSW", "Meaning": "Store status word", "Notes": None}, "FSUB": {"Instruction": "FSUB", "Meaning": "Subtract", "Notes": None}, "FSUBP": {"Instruction": "FSUBP", "Meaning": "Subtract and pop", "Notes": None}, "FSUBR": {"Instruction": "FSUBR", "Meaning": "Reverse subtract", "Notes": None}, "FSUBRP": {"Instruction": "FSUBRP", "Meaning": "Reverse subtract and pop", "Notes": None}, "FTST": {"Instruction": "FTST", "Meaning": "Test for zero", "Notes": None}, "FWAIT": {"Instruction": "FWAIT", "Meaning": "Wait while FPU is executing", "Notes": None}, "FXAM": {"Instruction": "FXAM", "Meaning": "Examine condition flags", "Notes": None}, "FXCH": {"Instruction": "FXCH", "Meaning": "Exchange registers", "Notes": None}, "FXTRACT": {"Instruction": "FXTRACT", "Meaning": "Extract exponent and significand", "Notes": None}, "FYL2X": {"Instruction": "FYL2X", "Meaning": "y\u00a0\u00b7\u00a0log2\u00a0x", "Notes": "if y\u00a0=\u00a0logb\u00a02, then the base-b logarithm is computed"}, "FYL2XP1": {"Instruction": "FYL2XP1", "Meaning": "y\u00a0\u00b7\u00a0log2\u00a0(x+1)", "Notes": "more precise than log2\u00a0z if x is close to zero"}, "FSETPM": {"Instruction": "FSETPM", "Meaning": "Set protected mode", "Notes": "80287 only, otherwise FNOP"}, "FCOS": {"Instruction": "FCOS", "Meaning": "Cosine", "Notes": None}, "FLDENVD": {"Instruction": "FLDENVD", "Meaning": "Load environment state, 32-bit", "Notes": None}, "FSAVED": {"Instruction": "FSAVED", "Meaning": "Save FPU state, 32-bit", "Notes": None}, "FSTENVD": {"Instruction": "FSTENVD", "Meaning": "Store FPU environment, 32-bit", "Notes": None}, "FPREM1": {"Instruction": "FPREM1", "Meaning": "Partial remainder", "Notes": "Computes IEEE remainder"}, "FRSTORD": {"Instruction": "FRSTORD", "Meaning": "Restore saved state, 32-bit", "Notes": None}, "FSIN": {"Instruction": "FSIN", "Meaning": "Sine", "Notes": None}, "FSINCOS": {"Instruction": "FSINCOS", "Meaning": "Sine and cosine", "Notes": None}, "FUCOM": {"Instruction": "FUCOM", "Meaning": "Unordered compare", "Notes": None}, "FUCOMP": {"Instruction": "FUCOMP", "Meaning": "Unordered compare and pop", "Notes": None}, "FUCOMPP": {"Instruction": "FUCOMPP", "Meaning": "Unordered compare and pop twice", "Notes": None}, "EMMS": {"Instruction": "EMMS", "Opcode": "0F 77", "Meaning": "Empty MMX Technology State", "Notes": "Marks all x87 FPU registers for use by FPU"}, "MOVD mm, r/m32": {"Instruction": "MOVD mm, r/m32", "Opcode": "0F 6E /r", "Meaning": "Move doubleword", "Notes": None}, "MOVD r/m32, mm": {"Instruction": "MOVD r/m32, mm", "Opcode": "0F 7E /r", "Meaning": "Move doubleword", "Notes": None}, "MOVQ mm/m64, mm": {"Instruction": "MOVQ mm/m64, mm", "Opcode": "0F 7F /r", "Meaning": "Move quadword", "Notes": None}, "MOVQ mm, mm/m64": {"Instruction": "MOVQ mm, mm/m64", "Opcode": "0F 6F /r", "Meaning": "Move quadword", "Notes": None}, "MOVQ mm, r/m64": {"Instruction": "MOVQ mm, r/m64", "Opcode": "REX.W + 0F 6E /r", "Meaning": "Move quadword", "Notes": None}, "MOVQ r/m64, mm": {"Instruction": "MOVQ r/m64, mm", "Opcode": "REX.W + 0F 7E /r", "Meaning": "Move quadword", "Notes": None}, "PACKSSDW mm1, mm2/m64": {"Instruction": "PACKSSDW mm1, mm2/m64", "Opcode": "0F 6B /r", "Meaning": "Pack doublewords to words (signed with saturation)", "Notes": None}, "PACKSSWB mm1, mm2/m64": {"Instruction": "PACKSSWB mm1, mm2/m64", "Opcode": "0F 63 /r", "Meaning": "Pack words to bytes (signed with saturation)", "Notes": None}, "PACKUSWB mm, mm/m64": {"Instruction": "PACKUSWB mm, mm/m64", "Opcode": "0F 67 /r", "Meaning": "Pack words to bytes (unsigned with saturation)", "Notes": None}, "PADDB mm, mm/m64": {"Instruction": "PADDB mm, mm/m64", "Opcode": "0F FC /r", "Meaning": "Add packed byte integers", "Notes": None}, "PADDW mm, mm/m64": {"Instruction": "PADDW mm, mm/m64", "Opcode": "0F FD /r", "Meaning": "Add packed word integers", "Notes": None}, "PADDD mm, mm/m64": {"Instruction": "PADDD mm, mm/m64", "Opcode": "0F FE /r", "Meaning": "Add packed doubleword integers", "Notes": None}, "PADDQ mm, mm/m64": {"Instruction": "PADDQ mm, mm/m64", "Opcode": "0F D4 /r", "Meaning": "Add packed quadword integers", "Notes": None}, "PADDSB mm, mm/m64": {"Instruction": "PADDSB mm, mm/m64", "Opcode": "0F EC /r", "Meaning": "Add packed signed byte integers and saturate", "Notes": None}, "PADDSW mm, mm/m64": {"Instruction": "PADDSW mm, mm/m64", "Opcode": "0F ED /r", "Meaning": "Add packed signed word integers and saturate", "Notes": None}, "PADDUSB mm, mm/m64": {"Instruction": "PADDUSB mm, mm/m64", "Opcode": "0F DC /r", "Meaning": "Add packed unsigned byte integers and saturate", "Notes": None}, "PADDUSW mm, mm/m64": {"Instruction": "PADDUSW mm, mm/m64", "Opcode": "0F DD /r", "Meaning": "Add packed unsigned word integers and saturate", "Notes": None}, "PAND mm, mm/m64": {"Instruction": "PAND mm, mm/m64", "Opcode": "0F DB /r", "Meaning": "Bitwise AND", "Notes": None}, "PANDN mm, mm/m64": {"Instruction": "PANDN mm, mm/m64", "Opcode": "0F DF /r", "Meaning": "Bitwise AND NOT", "Notes": None}, "POR mm, mm/m64": {"Instruction": "POR mm, mm/m64", "Opcode": "0F EB /r", "Meaning": "Bitwise OR", "Notes": None}, "PXOR mm, mm/m64": {"Instruction": "PXOR mm, mm/m64", "Opcode": "0F EF /r", "Meaning": "Bitwise XOR", "Notes": None}, "PCMPEQB mm, mm/m64": {"Instruction": "PCMPEQB mm, mm/m64", "Opcode": "0F 74 /r", "Meaning": "Compare packed bytes for equality", "Notes": None}, "PCMPEQW mm, mm/m64": {"Instruction": "PCMPEQW mm, mm/m64", "Opcode": "0F 75 /r", "Meaning": "Compare packed words for equality", "Notes": None}, "PCMPEQD mm, mm/m64": {"Instruction": "PCMPEQD mm, mm/m64", "Opcode": "0F 76 /r", "Meaning": "Compare packed doublewords for equality", "Notes": None}, "PCMPGTB mm, mm/m64": {"Instruction": "PCMPGTB mm, mm/m64", "Opcode": "0F 64 /r", "Meaning": "Compare packed signed byte integers for greater than", "Notes": None}, "PCMPGTW mm, mm/m64": {"Instruction": "PCMPGTW mm, mm/m64", "Opcode": "0F 65 /r", "Meaning": "Compare packed signed word integers for greater than", "Notes": None}, "PCMPGTD mm, mm/m64": {"Instruction": "PCMPGTD mm, mm/m64", "Opcode": "0F 66 /r", "Meaning": "Compare packed signed doubleword integers for greater than", "Notes": None}, "PMADDWD mm, mm/m64": {"Instruction": "PMADDWD mm, mm/m64", "Opcode": "0F F5 /r", "Meaning": "Multiply packed words, add adjacent doubleword results", "Notes": None}, "PMULHW mm, mm/m64": {"Instruction": "PMULHW mm, mm/m64", "Opcode": "0F E5 /r", "Meaning": "Multiply packed signed word integers, store high 16 bits of results", "Notes": None}, "PMULLW mm, mm/m64": {"Instruction": "PMULLW mm, mm/m64", "Opcode": "0F D5 /r", "Meaning": "Multiply packed signed word integers, store low 16 bits of results", "Notes": None}, "PSLLW mm1, imm8": {"Instruction": "PSLLW mm1, imm8", "Opcode": "0F 71 /6 ib", "Meaning": "Shift left words, shift in zeros", "Notes": None}, "PSLLW mm, mm/m64": {"Instruction": "PSLLW mm, mm/m64", "Opcode": "0F F1 /r", "Meaning": "Shift left words, shift in zeros", "Notes": None}, "PSLLD mm, imm8": {"Instruction": "PSLLD mm, imm8", "Opcode": "0F 72 /6 ib", "Meaning": "Shift left doublewords, shift in zeros", "Notes": None}, "PSLLD mm, mm/m64": {"Instruction": "PSLLD mm, mm/m64", "Opcode": "0F F2 /r", "Meaning": "Shift left doublewords, shift in zeros", "Notes": None}, "PSLLQ mm, imm8": {"Instruction": "PSLLQ mm, imm8", "Opcode": "0F 73 /6 ib", "Meaning": "Shift left quadword, shift in zeros", "Notes": None}, "PSLLQ mm, mm/m64": {"Instruction": "PSLLQ mm, mm/m64", "Opcode": "0F F3 /r", "Meaning": "Shift left quadword, shift in zeros", "Notes": None}, "PSRAD mm, imm8": {"Instruction": "PSRAD mm, imm8", "Opcode": "0F 72 /4 ib", "Meaning": "Shift right doublewords, shift in sign bits", "Notes": None}, "PSRAD mm, mm/m64": {"Instruction": "PSRAD mm, mm/m64", "Opcode": "0F E2 /r", "Meaning": "Shift right doublewords, shift in sign bits", "Notes": None}, "PSRAW mm, imm8": {"Instruction": "PSRAW mm, imm8", "Opcode": "0F 71 /4 ib", "Meaning": "Shift right words, shift in sign bits", "Notes": None}, "PSRAW mm, mm/m64": {"Instruction": "PSRAW mm, mm/m64", "Opcode": "0F E1 /r", "Meaning": "Shift right words, shift in sign bits", "Notes": None}, "PSRLW mm, imm8": {"Instruction": "PSRLW mm, imm8", "Opcode": "0F 71 /2 ib", "Meaning": "Shift right words, shift in zeros", "Notes": None}, "PSRLW mm, mm/m64": {"Instruction": "PSRLW mm, mm/m64", "Opcode": "0F D1 /r", "Meaning": "Shift right words, shift in zeros", "Notes": None}, "PSRLD mm, imm8": {"Instruction": "PSRLD mm, imm8", "Opcode": "0F 72 /2 ib", "Meaning": "Shift right doublewords, shift in zeros", "Notes": None}, "PSRLD mm, mm/m64": {"Instruction": "PSRLD mm, mm/m64", "Opcode": "0F D2 /r", "Meaning": "Shift right doublewords, shift in zeros", "Notes": None}, "PSRLQ mm, imm8": {"Instruction": "PSRLQ mm, imm8", "Opcode": "0F 73 /2 ib", "Meaning": "Shift right quadword, shift in zeros", "Notes": None}, "PSRLQ mm, mm/m64": {"Instruction": "PSRLQ mm, mm/m64", "Opcode": "0F D3 /r", "Meaning": "Shift right quadword, shift in zeros", "Notes": None}, "PSUBB mm, mm/m64": {"Instruction": "PSUBB mm, mm/m64", "Opcode": "0F F8 /r", "Meaning": "Subtract packed byte integers", "Notes": None}, "PSUBW mm, mm/m64": {"Instruction": "PSUBW mm, mm/m64", "Opcode": "0F F9 /r", "Meaning": "Subtract packed word integers", "Notes": None}, "PSUBD mm, mm/m64": {"Instruction": "PSUBD mm, mm/m64", "Opcode": "0F FA /r", "Meaning": "Subtract packed doubleword integers", "Notes": None}, "PSUBSB mm, mm/m64": {"Instruction": "PSUBSB mm, mm/m64", "Opcode": "0F E8 /r", "Meaning": "Subtract signed packed bytes with saturation", "Notes": None}, "PSUBSW mm, mm/m64": {"Instruction": "PSUBSW mm, mm/m64", "Opcode": "0F E9 /r", "Meaning": "Subtract signed packed words with saturation", "Notes": None}, "PSUBUSB mm, mm/m64": {"Instruction": "PSUBUSB mm, mm/m64", "Opcode": "0F D8 /r", "Meaning": "Subtract unsigned packed bytes with saturation", "Notes": None}, "PSUBUSW mm, mm/m64": {"Instruction": "PSUBUSW mm, mm/m64", "Opcode": "0F D9 /r", "Meaning": "Subtract unsigned packed words with saturation", "Notes": None}, "PUNPCKHBW mm, mm/m64": {"Instruction": "PUNPCKHBW mm, mm/m64", "Opcode": "0F 68 /r", "Meaning": "Unpack and interleave high-order bytes", "Notes": None}, "PUNPCKHWD mm, mm/m64": {"Instruction": "PUNPCKHWD mm, mm/m64", "Opcode": "0F 69 /r", "Meaning": "Unpack and interleave high-order words", "Notes": None}, "PUNPCKHDQ mm, mm/m64": {"Instruction": "PUNPCKHDQ mm, mm/m64", "Opcode": "0F 6A /r", "Meaning": "Unpack and interleave high-order doublewords", "Notes": None}, "PUNPCKLBW mm, mm/m32": {"Instruction": "PUNPCKLBW mm, mm/m32", "Opcode": "0F 60 /r", "Meaning": "Unpack and interleave low-order bytes", "Notes": None}, "PUNPCKLWD mm, mm/m32": {"Instruction": "PUNPCKLWD mm, mm/m32", "Opcode": "0F 61 /r", "Meaning": "Unpack and interleave low-order words", "Notes": None}, "PUNPCKLDQ mm, mm/m32": {"Instruction": "PUNPCKLDQ mm, mm/m32", "Opcode": "0F 62 /r", "Meaning": "Unpack and interleave low-order doublewords", "Notes": None}, "PSHUFW mm1, mm2/m64, imm8": {"Instruction": "PSHUFW mm1, mm2/m64, imm8", "Opcode": "0F 70 /r ib", "Meaning": "Shuffle Packed Words"}, "PINSRW mm, r32/m16, imm8": {"Instruction": "PINSRW mm, r32/m16, imm8", "Opcode": "0F C4 /r", "Meaning": "Insert Word"}, "PEXTRW reg, mm, imm8": {"Instruction": "PEXTRW reg, mm, imm8", "Opcode": "0F C5 /r", "Meaning": "Extract Word"}, "PMOVMSKB reg, mm": {"Instruction": "PMOVMSKB reg, mm", "Opcode": "0F D7 /r", "Meaning": "Move Byte Mask"}, "PMINUB mm1, mm2/m64": {"Instruction": "PMINUB mm1, mm2/m64", "Opcode": "0F DA /r", "Meaning": "Minimum of Packed Unsigned Byte Integers"}, "PMAXUB mm1, mm2/m64": {"Instruction": "PMAXUB mm1, mm2/m64", "Opcode": "0F DE /r", "Meaning": "Maximum of Packed Unsigned Byte Integers"}, "PAVGB mm1, mm2/m64": {"Instruction": "PAVGB mm1, mm2/m64", "Opcode": "0F E0 /r", "Meaning": "Average Packed Integers"}, "PAVGW mm1, mm2/m64": {"Instruction": "PAVGW mm1, mm2/m64", "Opcode": "0F E3 /r", "Meaning": "Average Packed Integers"}, "PMULHUW mm1, mm2/m64": {"Instruction": "PMULHUW mm1, mm2/m64", "Opcode": "0F E4 /r", "Meaning": "Multiply Packed Unsigned Integers and Store High Result"}, "PMINSW mm1, mm2/m64": {"Instruction": "PMINSW mm1, mm2/m64", "Opcode": "0F EA /r", "Meaning": "Minimum of Packed Signed Word Integers"}, "PMAXSW mm1, mm2/m64": {"Instruction": "PMAXSW mm1, mm2/m64", "Opcode": "0F EE /r", "Meaning": "Maximum of Packed Signed Word Integers"}, "PSADBW mm1, mm2/m64": {"Instruction": "PSADBW mm1, mm2/m64", "Opcode": "0F F6 /r", "Meaning": "Compute Sum of Absolute Differences"}, "PSUBQ mm1, mm2/m64": {"Instruction": "PSUBQ mm1, mm2/m64", "Opcode": "0F FB /r", "Meaning": "Subtract quadword integer"}, "PMULUDQ mm1, mm2/m64": {"Instruction": "PMULUDQ mm1, mm2/m64", "Opcode": "0F F4 /r", "Meaning": "Multiply unsigned doubleword integer"}, "PSIGNB mm1, mm2/m64": {"Instruction": "PSIGNB mm1, mm2/m64", "Opcode": "0F 38 08 /r", "Meaning": "Negate/zero/preserve packed byte integers depending on corresponding sign"}, "PSIGNW mm1, mm2/m64": {"Instruction": "PSIGNW mm1, mm2/m64", "Opcode": "0F 38 09 /r", "Meaning": "Negate/zero/preserve packed word integers depending on corresponding sign"}, "PSIGND mm1, mm2/m64": {"Instruction": "PSIGND mm1, mm2/m64", "Opcode": "0F 38 0A /r", "Meaning": "Negate/zero/preserve packed doubleword integers depending on corresponding sign"}, "PSHUFB mm1, mm2/m64": {"Instruction": "PSHUFB mm1, mm2/m64", "Opcode": "0F 38 00 /r", "Meaning": "Shuffle bytes"}, "PMULHRSW mm1, mm2/m64": {"Instruction": "PMULHRSW mm1, mm2/m64", "Opcode": "0F 38 0B /r", "Meaning": "Multiply 16-bit signed words, scale and round signed doublewords, pack high 16 bits"}, "PMADDUBSW mm1, mm2/m64": {"Instruction": "PMADDUBSW mm1, mm2/m64", "Opcode": "0F 38 04 /r", "Meaning": "Multiply signed and unsigned bytes, add horizontal pair of signed words, pack saturated signed-words"}, "PHSUBW mm1, mm2/m64": {"Instruction": "PHSUBW mm1, mm2/m64", "Opcode": "0F 38 05 /r", "Meaning": "Subtract and pack 16-bit signed integers horizontally"}, "PHSUBSW mm1, mm2/m64": {"Instruction": "PHSUBSW mm1, mm2/m64", "Opcode": "0F 38 07 /r", "Meaning": "Subtract and pack 16-bit signed integer horizontally with saturation"}, "PHSUBD mm1, mm2/m64": {"Instruction": "PHSUBD mm1, mm2/m64", "Opcode": "0F 38 06 /r", "Meaning": "Subtract and pack 32-bit signed integers horizontally"}, "PHADDSW mm1, mm2/m64": {"Instruction": "PHADDSW mm1, mm2/m64", "Opcode": "0F 38 03 /r", "Meaning": "Add and pack 16-bit signed integers horizontally, pack saturated integers to mm1."}, "PHADDW mm1, mm2/m64": {"Instruction": "PHADDW mm1, mm2/m64", "Opcode": "0F 38 01 /r", "Meaning": "Add and pack 16-bit integers horizontally"}, "PHADDD mm1, mm2/m64": {"Instruction": "PHADDD mm1, mm2/m64", "Opcode": "0F 38 02 /r", "Meaning": "Add and pack 32-bit integers horizontally"}, "PALIGNR mm1, mm2/m64, imm8": {"Instruction": "PALIGNR mm1, mm2/m64, imm8", "Opcode": "0F 3A 0F /r ib", "Meaning": "Concatenate destination and source operands, extract byte-aligned result shifted to the right"}, "PABSB mm1, mm2/m64": {"Instruction": "PABSB mm1, mm2/m64", "Opcode": "0F 38 1C /r", "Meaning": "Compute the absolute value of bytes and store unsigned result"}, "PABSW mm1, mm2/m64": {"Instruction": "PABSW mm1, mm2/m64", "Opcode": "0F 38 1D /r", "Meaning": "Compute the absolute value of 16-bit integers and store unsigned result"}, "PABSD mm1, mm2/m64": {"Instruction": "PABSD mm1, mm2/m64", "Opcode": "0F 38 1E /r", "Meaning": "Compute the absolute value of 32-bit integers and store unsigned result"}, "ANDPS* xmm1, xmm2/m128": {"Instruction": "ANDPS* xmm1, xmm2/m128", "Opcode": "0F 54 /r", "Meaning": "Bitwise Logical AND of Packed Single-Precision Floating-Point Values"}, "ANDNPS* xmm1, xmm2/m128": {"Instruction": "ANDNPS* xmm1, xmm2/m128", "Opcode": "0F 55 /r", "Meaning": "Bitwise Logical AND NOT of Packed Single-Precision Floating-Point Values"}, "ORPS* xmm1, xmm2/m128": {"Instruction": "ORPS* xmm1, xmm2/m128", "Opcode": "0F 56 /r", "Meaning": "Bitwise Logical OR of Single-Precision Floating-Point Values"}, "XORPS* xmm1, xmm2/m128": {"Instruction": "XORPS* xmm1, xmm2/m128", "Opcode": "0F 57 /r", "Meaning": "Bitwise Logical XOR for Single-Precision Floating-Point Values"}, "MOVUPS xmm1, xmm2/m128": {"Instruction": "MOVUPS xmm1, xmm2/m128", "Opcode": "0F 10 /r", "Meaning": "Move Unaligned Packed Single-Precision Floating-Point Values"}, "MOVSS xmm1, xmm2/m32": {"Instruction": "MOVSS xmm1, xmm2/m32", "Opcode": "F3 0F 10 /r", "Meaning": "Move Scalar Single-Precision Floating-Point Values"}, "MOVUPS xmm2/m128, xmm1": {"Instruction": "MOVUPS xmm2/m128, xmm1", "Opcode": "0F 11 /r", "Meaning": "Move Unaligned Packed Single-Precision Floating-Point Values"}, "MOVSS xmm2/m32, xmm1": {"Instruction": "MOVSS xmm2/m32, xmm1", "Opcode": "F3 0F 11 /r", "Meaning": "Move Scalar Single-Precision Floating-Point Values"}, "MOVLPS xmm, m64": {"Instruction": "MOVLPS xmm, m64", "Opcode": "0F 12 /r", "Meaning": "Move Low Packed Single-Precision Floating-Point Values"}, "MOVHLPS xmm1, xmm2": {"Instruction": "MOVHLPS xmm1, xmm2", "Opcode": "0F 12 /r", "Meaning": "Move Packed Single-Precision Floating-Point Values High to Low"}, "MOVLPS m64, xmm": {"Instruction": "MOVLPS m64, xmm", "Opcode": "0F 13 /r", "Meaning": "Move Low Packed Single-Precision Floating-Point Values"}, "UNPCKLPS xmm1, xmm2/m128": {"Instruction": "UNPCKLPS xmm1, xmm2/m128", "Opcode": "0F 14 /r", "Meaning": "Unpack and Interleave Low Packed Single-Precision Floating-Point Values"}, "UNPCKHPS xmm1, xmm2/m128": {"Instruction": "UNPCKHPS xmm1, xmm2/m128", "Opcode": "0F 15 /r", "Meaning": "Unpack and Interleave High Packed Single-Precision Floating-Point Values"}, "MOVHPS xmm, m64": {"Instruction": "MOVHPS xmm, m64", "Opcode": "0F 16 /r", "Meaning": "Move High Packed Single-Precision Floating-Point Values"}, "MOVLHPS xmm1, xmm2": {"Instruction": "MOVLHPS xmm1, xmm2", "Opcode": "0F 16 /r", "Meaning": "Move Packed Single-Precision Floating-Point Values Low to High"}, "MOVHPS m64, xmm": {"Instruction": "MOVHPS m64, xmm", "Opcode": "0F 17 /r", "Meaning": "Move High Packed Single-Precision Floating-Point Values"}, "MOVAPS xmm1, xmm2/m128": {"Instruction": "MOVAPS xmm1, xmm2/m128", "Opcode": "0F 28 /r", "Meaning": "Move Aligned Packed Single-Precision Floating-Point Values"}, "MOVAPS xmm2/m128, xmm1": {"Instruction": "MOVAPS xmm2/m128, xmm1", "Opcode": "0F 29 /r", "Meaning": "Move Aligned Packed Single-Precision Floating-Point Values"}, "MOVMSKPS reg, xmm": {"Instruction": "MOVMSKPS reg, xmm", "Opcode": "0F 50 /r", "Meaning": "Extract Packed Single-Precision Floating-Point 4-bit Sign Mask. The upper bits of the register are filled with zeros."}, "CVTPI2PS xmm, mm/m64": {"Instruction": "CVTPI2PS xmm, mm/m64", "Opcode": "0F 2A /r", "Meaning": "Convert Packed Dword Integers to Packed Single-Precision FP Values"}, "CVTSI2SS xmm, r/m32": {"Instruction": "CVTSI2SS xmm, r/m32", "Opcode": "F3 0F 2A /r", "Meaning": "Convert Dword Integer to Scalar Single-Precision FP Value"}, "CVTSI2SS xmm, r/m64": {"Instruction": "CVTSI2SS xmm, r/m64", "Opcode": "F3 REX.W 0F 2A /r", "Meaning": "Convert Qword Integer to Scalar Single-Precision FP Value"}, "MOVNTPS m128, xmm": {"Instruction": "MOVNTPS m128, xmm", "Opcode": "0F 2B /r", "Meaning": "Store Packed Single-Precision Floating-Point Values Using Non-Temporal Hint"}, "CVTTPS2PI mm, xmm/m64": {"Instruction": "CVTTPS2PI mm, xmm/m64", "Opcode": "0F 2C /r", "Meaning": "Convert with Truncation Packed Single-Precision FP Values to Packed Dword Integers"}, "CVTTSS2SI r32, xmm/m32": {"Instruction": "CVTTSS2SI r32, xmm/m32", "Opcode": "F3 0F 2C /r", "Meaning": "Convert with Truncation Scalar Single-Precision FP Value to Dword Integer"}, "CVTTSS2SI r64, xmm1/m32": {"Instruction": "CVTTSS2SI r64, xmm1/m32", "Opcode": "F3 REX.W 0F 2C /r", "Meaning": "Convert with Truncation Scalar Single-Precision FP Value to Qword Integer"}, "CVTPS2PI mm, xmm/m64": {"Instruction": "CVTPS2PI mm, xmm/m64", "Opcode": "0F 2D /r", "Meaning": "Convert Packed Single-Precision FP Values to Packed Dword Integers"}, "CVTSS2SI r32, xmm/m32": {"Instruction": "CVTSS2SI r32, xmm/m32", "Opcode": "F3 0F 2D /r", "Meaning": "Convert Scalar Single-Precision FP Value to Dword Integer"}, "CVTSS2SI r64, xmm1/m32": {"Instruction": "CVTSS2SI r64, xmm1/m32", "Opcode": "F3 REX.W 0F 2D /r", "Meaning": "Convert Scalar Single-Precision FP Value to Qword Integer"}, "UCOMISS xmm1, xmm2/m32": {"Instruction": "UCOMISS xmm1, xmm2/m32", "Opcode": "0F 2E /r", "Meaning": "Unordered Compare Scalar Single-Precision Floating-Point Values and Set EFLAGS"}, "COMISS xmm1, xmm2/m32": {"Instruction": "COMISS xmm1, xmm2/m32", "Opcode": "0F 2F /r", "Meaning": "Compare Scalar Ordered Single-Precision Floating-Point Values and Set EFLAGS"}, "SQRTPS xmm1, xmm2/m128": {"Instruction": "SQRTPS xmm1, xmm2/m128", "Opcode": "0F 51 /r", "Meaning": "Compute Square Roots of Packed Single-Precision Floating-Point Values"}, "SQRTSS xmm1, xmm2/m32": {"Instruction": "SQRTSS xmm1, xmm2/m32", "Opcode": "F3 0F 51 /r", "Meaning": "Compute Square Root of Scalar Single-Precision Floating-Point Value"}, "RSQRTPS xmm1, xmm2/m128": {"Instruction": "RSQRTPS xmm1, xmm2/m128", "Opcode": "0F 52 /r", "Meaning": "Compute Reciprocal of Square Root of Packed Single-Precision Floating-Point Value"}, "RSQRTSS xmm1, xmm2/m32": {"Instruction": "RSQRTSS xmm1, xmm2/m32", "Opcode": "F3 0F 52 /r", "Meaning": "Compute Reciprocal of Square Root of Scalar Single-Precision Floating-Point Value"}, "RCPPS xmm1, xmm2/m128": {"Instruction": "RCPPS xmm1, xmm2/m128", "Opcode": "0F 53 /r", "Meaning": "Compute Reciprocal of Packed Single-Precision Floating-Point Values"}, "RCPSS xmm1, xmm2/m32": {"Instruction": "RCPSS xmm1, xmm2/m32", "Opcode": "F3 0F 53 /r", "Meaning": "Compute Reciprocal of Scalar Single-Precision Floating-Point Values"}, "ADDPS xmm1, xmm2/m128": {"Instruction": "ADDPS xmm1, xmm2/m128", "Opcode": "0F 58 /r", "Meaning": "Add Packed Single-Precision Floating-Point Values"}, "ADDSS xmm1, xmm2/m32": {"Instruction": "ADDSS xmm1, xmm2/m32", "Opcode": "F3 0F 58 /r", "Meaning": "Add Scalar Single-Precision Floating-Point Values"}, "MULPS xmm1, xmm2/m128": {"Instruction": "MULPS xmm1, xmm2/m128", "Opcode": "0F 59 /r", "Meaning": "Multiply Packed Single-Precision Floating-Point Values"}, "MULSS xmm1, xmm2/m32": {"Instruction": "MULSS xmm1, xmm2/m32", "Opcode": "F3 0F 59 /r", "Meaning": "Multiply Scalar Single-Precision Floating-Point Values"}, "SUBPS xmm1, xmm2/m128": {"Instruction": "SUBPS xmm1, xmm2/m128", "Opcode": "0F 5C /r", "Meaning": "Subtract Packed Single-Precision Floating-Point Values"}, "SUBSS xmm1, xmm2/m32": {"Instruction": "SUBSS xmm1, xmm2/m32", "Opcode": "F3 0F 5C /r", "Meaning": "Subtract Scalar Single-Precision Floating-Point Values"}, "MINPS xmm1, xmm2/m128": {"Instruction": "MINPS xmm1, xmm2/m128", "Opcode": "0F 5D /r", "Meaning": "Return Minimum Packed Single-Precision Floating-Point Values"}, "MINSS xmm1, xmm2/m32": {"Instruction": "MINSS xmm1, xmm2/m32", "Opcode": "F3 0F 5D /r", "Meaning": "Return Minimum Scalar Single-Precision Floating-Point Values"}, "DIVPS xmm1, xmm2/m128": {"Instruction": "DIVPS xmm1, xmm2/m128", "Opcode": "0F 5E /r", "Meaning": "Divide Packed Single-Precision Floating-Point Values"}, "DIVSS xmm1, xmm2/m32": {"Instruction": "DIVSS xmm1, xmm2/m32", "Opcode": "F3 0F 5E /r", "Meaning": "Divide Scalar Single-Precision Floating-Point Values"}, "MAXPS xmm1, xmm2/m128": {"Instruction": "MAXPS xmm1, xmm2/m128", "Opcode": "0F 5F /r", "Meaning": "Return Maximum Packed Single-Precision Floating-Point Values"}, "MAXSS xmm1, xmm2/m32": {"Instruction": "MAXSS xmm1, xmm2/m32", "Opcode": "F3 0F 5F /r", "Meaning": "Return Maximum Scalar Single-Precision Floating-Point Values"}, "LDMXCSR m32": {"Instruction": "LDMXCSR m32", "Opcode": "0F AE /2", "Meaning": "Load MXCSR Register State"}, "STMXCSR m32": {"Instruction": "STMXCSR m32", "Opcode": "0F AE /3", "Meaning": "Store MXCSR Register State"}, "CMPPS xmm1, xmm2/m128, imm8": {"Instruction": "CMPPS xmm1, xmm2/m128, imm8", "Opcode": "0F C2 /r ib", "Meaning": "Compare Packed Single-Precision Floating-Point Values"}, "CMPSS xmm1, xmm2/m32, imm8": {"Instruction": "CMPSS xmm1, xmm2/m32, imm8", "Opcode": "F3 0F C2 /r ib", "Meaning": "Compare Scalar Single-Precision Floating-Point Values"}, "SHUFPS xmm1, xmm2/m128, imm8": {"Instruction": "SHUFPS xmm1, xmm2/m128, imm8", "Opcode": "0F C6 /r ib", "Meaning": "Shuffle Packed Single-Precision Floating-Point Values"}, "MOVAPD xmm1, xmm2/m128": {"Instruction": "MOVAPD xmm1, xmm2/m128", "Opcode": "66 0F 28 /r", "Meaning": "Move Aligned Packed Double-Precision Floating-Point Values"}, "MOVAPD xmm2/m128, xmm1": {"Instruction": "MOVAPD xmm2/m128, xmm1", "Opcode": "66 0F 29 /r", "Meaning": "Move Aligned Packed Double-Precision Floating-Point Values"}, "MOVNTPD m128, xmm1": {"Instruction": "MOVNTPD m128, xmm1", "Opcode": "66 0F 2B /r", "Meaning": "Store Packed Double-Precision Floating-Point Values Using Non-Temporal Hint"}, "MOVHPD xmm1, m64": {"Instruction": "MOVHPD xmm1, m64", "Opcode": "66 0F 16 /r", "Meaning": "Move High Packed Double-Precision Floating-Point Value"}, "MOVHPD m64, xmm1": {"Instruction": "MOVHPD m64, xmm1", "Opcode": "66 0F 17 /r", "Meaning": "Move High Packed Double-Precision Floating-Point Value"}, "MOVLPD xmm1, m64": {"Instruction": "MOVLPD xmm1, m64", "Opcode": "66 0F 12 /r", "Meaning": "Move Low Packed Double-Precision Floating-Point Value"}, "MOVLPD m64, xmm1": {"Instruction": "MOVLPD m64, xmm1", "Opcode": "66 0F 13/r", "Meaning": "Move Low Packed Double-Precision Floating-Point Value"}, "MOVUPD xmm1, xmm2/m128": {"Instruction": "MOVUPD xmm1, xmm2/m128", "Opcode": "66 0F 10 /r", "Meaning": "Move Unaligned Packed Double-Precision Floating-Point Values"}, "MOVUPD xmm2/m128, xmm1": {"Instruction": "MOVUPD xmm2/m128, xmm1", "Opcode": "66 0F 11 /r", "Meaning": "Move Unaligned Packed Double-Precision Floating-Point Values"}, "MOVMSKPD reg, xmm": {"Instruction": "MOVMSKPD reg, xmm", "Opcode": "66 0F 50 /r", "Meaning": "Extract Packed Double-Precision Floating-Point Sign Mask"}, "MOVSD* xmm1, xmm2/m64": {"Instruction": "MOVSD* xmm1, xmm2/m64", "Opcode": "F2 0F 10 /r", "Meaning": "Move or Merge Scalar Double-Precision Floating-Point Value"}, "MOVSD xmm1/m64, xmm2": {"Instruction": "MOVSD xmm1/m64, xmm2", "Opcode": "F2 0F 11 /r", "Meaning": "Move or Merge Scalar Double-Precision Floating-Point Value"}, "ADDPD xmm1, xmm2/m128": {"Instruction": "ADDPD xmm1, xmm2/m128", "Opcode": "66 0F 58 /r", "Meaning": "Add Packed Double-Precision Floating-Point Values"}, "ADDSD xmm1, xmm2/m64": {"Instruction": "ADDSD xmm1, xmm2/m64", "Opcode": "F2 0F 58 /r", "Meaning": "Add Low Double-Precision Floating-Point Value"}, "DIVPD xmm1, xmm2/m128": {"Instruction": "DIVPD xmm1, xmm2/m128", "Opcode": "66 0F 5E /r", "Meaning": "Divide Packed Double-Precision Floating-Point Values"}, "DIVSD xmm1, xmm2/m64": {"Instruction": "DIVSD xmm1, xmm2/m64", "Opcode": "F2 0F 5E /r", "Meaning": "Divide Scalar Double-Precision Floating-Point Value"}, "MAXPD xmm1, xmm2/m128": {"Instruction": "MAXPD xmm1, xmm2/m128", "Opcode": "66 0F 5F /r", "Meaning": "Maximum of Packed Double-Precision Floating-Point Values"}, "MAXSD xmm1, xmm2/m64": {"Instruction": "MAXSD xmm1, xmm2/m64", "Opcode": "F2 0F 5F /r", "Meaning": "Return Maximum Scalar Double-Precision Floating-Point Value"}, "MINPD xmm1, xmm2/m128": {"Instruction": "MINPD xmm1, xmm2/m128", "Opcode": "66 0F 5D /r", "Meaning": "Minimum of Packed Double-Precision Floating-Point Values"}, "MINSD xmm1, xmm2/m64": {"Instruction": "MINSD xmm1, xmm2/m64", "Opcode": "F2 0F 5D /r", "Meaning": "Return Minimum Scalar Double-Precision Floating-Point Value"}, "MULPD xmm1, xmm2/m128": {"Instruction": "MULPD xmm1, xmm2/m128", "Opcode": "66 0F 59 /r", "Meaning": "Multiply Packed Double-Precision Floating-Point Values"}, "MULSD xmm1,xmm2/m64": {"Instruction": "MULSD xmm1,xmm2/m64", "Opcode": "F2 0F 59 /r", "Meaning": "Multiply Scalar Double-Precision Floating-Point Value"}, "SQRTPD xmm1, xmm2/m128": {"Instruction": "SQRTPD xmm1, xmm2/m128", "Opcode": "66 0F 51 /r", "Meaning": "Square Root of Double-Precision Floating-Point Values"}, "SQRTSD xmm1,xmm2/m64": {"Instruction": "SQRTSD xmm1,xmm2/m64", "Opcode": "F2 0F 51/r", "Meaning": "Compute Square Root of Scalar Double-Precision Floating-Point Value"}, "SUBPD xmm1, xmm2/m128": {"Instruction": "SUBPD xmm1, xmm2/m128", "Opcode": "66 0F 5C /r", "Meaning": "Subtract Packed Double-Precision Floating-Point Values"}, "SUBSD xmm1, xmm2/m64": {"Instruction": "SUBSD xmm1, xmm2/m64", "Opcode": "F2 0F 5C /r", "Meaning": "Subtract Scalar Double-Precision Floating-Point Value"}, "ANDPD xmm1, xmm2/m128": {"Instruction": "ANDPD xmm1, xmm2/m128", "Opcode": "66 0F 54 /r", "Meaning": "Bitwise Logical AND of Packed Double Precision Floating-Point Values"}, "ANDNPD xmm1, xmm2/m128": {"Instruction": "ANDNPD xmm1, xmm2/m128", "Opcode": "66 0F 55 /r", "Meaning": "Bitwise Logical AND NOT of Packed Double Precision Floating-Point Values"}, "ORPD xmm1, xmm2/m128": {"Instruction": "ORPD xmm1, xmm2/m128", "Opcode": "66 0F 56/r", "Meaning": "Bitwise Logical OR of Packed Double Precision Floating-Point Values"}, "XORPD xmm1, xmm2/m128": {"Instruction": "XORPD xmm1, xmm2/m128", "Opcode": "66 0F 57/r", "Meaning": "Bitwise Logical XOR of Packed Double Precision Floating-Point Values"}, "CMPPD xmm1, xmm2/m128, imm8": {"Instruction": "CMPPD xmm1, xmm2/m128, imm8", "Opcode": "66 0F C2 /r ib", "Meaning": "Compare Packed Double-Precision Floating-Point Values"}, "CMPSD* xmm1, xmm2/m64, imm8": {"Instruction": "CMPSD* xmm1, xmm2/m64, imm8", "Opcode": "F2 0F C2 /r ib", "Meaning": "Compare Low Double-Precision Floating-Point Values"}, "COMISD xmm1, xmm2/m64": {"Instruction": "COMISD xmm1, xmm2/m64", "Opcode": "66 0F 2F /r", "Meaning": "Compare Scalar Ordered Double-Precision Floating-Point Values and Set EFLAGS"}, "UCOMISD xmm1, xmm2/m64": {"Instruction": "UCOMISD xmm1, xmm2/m64", "Opcode": "66 0F 2E /r", "Meaning": "Unordered Compare Scalar Double-Precision Floating-Point Values and Set EFLAGS"}, "SHUFPD xmm1, xmm2/m128, imm8": {"Instruction": "SHUFPD xmm1, xmm2/m128, imm8", "Opcode": "66 0F C6 /r ib", "Meaning": "Packed Interleave Shuffle of Pairs of Double-Precision Floating-Point Values"}, "UNPCKHPD xmm1, xmm2/m128": {"Instruction": "UNPCKHPD xmm1, xmm2/m128", "Opcode": "66 0F 15 /r", "Meaning": "Unpack and Interleave High Packed Double-Precision Floating-Point Values"}, "UNPCKLPD xmm1, xmm2/m128": {"Instruction": "UNPCKLPD xmm1, xmm2/m128", "Opcode": "66 0F 14 /r", "Meaning": "Unpack and Interleave Low Packed Double-Precision Floating-Point Values"}, "CVTDQ2PD xmm1, xmm2/m64": {"Instruction": "CVTDQ2PD xmm1, xmm2/m64", "Opcode": "F3 0F E6 /r", "Meaning": "Convert Packed Doubleword Integers to Packed Double-Precision Floating-Point Values"}, "CVTDQ2PS xmm1, xmm2/m128": {"Instruction": "CVTDQ2PS xmm1, xmm2/m128", "Opcode": "0F 5B /r", "Meaning": "Convert Packed Doubleword Integers to Packed Single-Precision Floating-Point Values"}, "CVTPD2DQ xmm1, xmm2/m128": {"Instruction": "CVTPD2DQ xmm1, xmm2/m128", "Opcode": "F2 0F E6 /r", "Meaning": "Convert Packed Double-Precision Floating-Point Values to Packed Doubleword Integers"}, "CVTPD2PI mm, xmm/m128": {"Instruction": "CVTPD2PI mm, xmm/m128", "Opcode": "66 0F 2D /r", "Meaning": "Convert Packed Double-Precision FP Values to Packed Dword Integers"}, "CVTPD2PS xmm1, xmm2/m128": {"Instruction": "CVTPD2PS xmm1, xmm2/m128", "Opcode": "66 0F 5A /r", "Meaning": "Convert Packed Double-Precision Floating-Point Values to Packed Single-Precision Floating-Point Values"}, "CVTPI2PD xmm, mm/m64": {"Instruction": "CVTPI2PD xmm, mm/m64", "Opcode": "66 0F 2A /r", "Meaning": "Convert Packed Dword Integers to Packed Double-Precision FP Values"}, "CVTPS2DQ xmm1, xmm2/m128": {"Instruction": "CVTPS2DQ xmm1, xmm2/m128", "Opcode": "66 0F 5B /r", "Meaning": "Convert Packed Single-Precision Floating-Point Values to Packed Signed Doubleword Integer Values"}, "CVTPS2PD xmm1, xmm2/m64": {"Instruction": "CVTPS2PD xmm1, xmm2/m64", "Opcode": "0F 5A /r", "Meaning": "Convert Packed Single-Precision Floating-Point Values to Packed Double-Precision Floating-Point Values"}, "CVTSD2SI r32, xmm1/m64": {"Instruction": "CVTSD2SI r32, xmm1/m64", "Opcode": "F2 0F 2D /r", "Meaning": "Convert Scalar Double-Precision Floating-Point Value to Doubleword Integer"}, "CVTSD2SI r64, xmm1/m64": {"Instruction": "CVTSD2SI r64, xmm1/m64", "Opcode": "F2 REX.W 0F 2D /r", "Meaning": "Convert Scalar Double-Precision Floating-Point Value to Quadword Integer With Sign Extension"}, "CVTSD2SS xmm1, xmm2/m64": {"Instruction": "CVTSD2SS xmm1, xmm2/m64", "Opcode": "F2 0F 5A /r", "Meaning": "Convert Scalar Double-Precision Floating-Point Value to Scalar Single-Precision Floating-Point Value"}, "CVTSI2SD xmm1, r32/m32": {"Instruction": "CVTSI2SD xmm1, r32/m32", "Opcode": "F2 0F 2A /r", "Meaning": "Convert Doubleword Integer to Scalar Double-Precision Floating-Point Value"}, "CVTSI2SD xmm1, r/m64": {"Instruction": "CVTSI2SD xmm1, r/m64", "Opcode": "F2 REX.W 0F 2A /r", "Meaning": "Convert Quadword Integer to Scalar Double-Precision Floating-Point value"}, "CVTSS2SD xmm1, xmm2/m32": {"Instruction": "CVTSS2SD xmm1, xmm2/m32", "Opcode": "F3 0F 5A /r", "Meaning": "Convert Scalar Single-Precision Floating-Point Value to Scalar Double-Precision Floating-Point Value"}, "CVTTPD2DQ xmm1, xmm2/m128": {"Instruction": "CVTTPD2DQ xmm1, xmm2/m128", "Opcode": "66 0F E6 /r", "Meaning": "Convert with Truncation Packed Double-Precision Floating-Point Values to Packed Doubleword Integers"}, "CVTTPD2PI mm, xmm/m128": {"Instruction": "CVTTPD2PI mm, xmm/m128", "Opcode": "66 0F 2C /r", "Meaning": "Convert with Truncation Packed Double-Precision FP Values to Packed Dword Integers"}, "CVTTPS2DQ xmm1, xmm2/m128": {"Instruction": "CVTTPS2DQ xmm1, xmm2/m128", "Opcode": "F3 0F 5B /r", "Meaning": "Convert with Truncation Packed Single-Precision Floating-Point Values to Packed Signed Doubleword Integer Values"}, "CVTTSD2SI r32, xmm1/m64": {"Instruction": "CVTTSD2SI r32, xmm1/m64", "Opcode": "F2 0F 2C /r", "Meaning": "Convert with Truncation Scalar Double-Precision Floating-Point Value to Signed Dword Integer"}, "CVTTSD2SI r64, xmm1/m64": {"Instruction": "CVTTSD2SI r64, xmm1/m64", "Opcode": "F2 REX.W 0F 2C /r", "Meaning": "Convert with Truncation Scalar Double-Precision Floating-Point Value To Signed Qword Integer"}, "MOVD xmm, r/m32": {"Instruction": "MOVD xmm, r/m32", "Opcode": "66 0F 6E /r", "Meaning": "Move doubleword"}, "MOVD r/m32, xmm": {"Instruction": "MOVD r/m32, xmm", "Opcode": "66 0F 7E /r", "Meaning": "Move doubleword"}, "MOVQ xmm1, xmm2/m64": {"Instruction": "MOVQ xmm1, xmm2/m64", "Opcode": "F3 0F 7E /r", "Meaning": "Move quadword"}, "MOVQ xmm2/m64, xmm1": {"Instruction": "MOVQ xmm2/m64, xmm1", "Opcode": "66 0F D6 /r", "Meaning": "Move quadword"}, "MOVQ r/m64, xmm": {"Instruction": "MOVQ r/m64, xmm", "Opcode": "66 REX.W 0F 7E /r", "Meaning": "Move quadword"}, "MOVQ xmm, r/m64": {"Instruction": "MOVQ xmm, r/m64", "Opcode": "66 REX.W 0F 6E /r", "Meaning": "Move quadword"}, "PMOVMSKB reg, xmm": {"Instruction": "PMOVMSKB reg, xmm", "Opcode": "66 0F D7 /r", "Meaning": "Move a byte mask, zeroing the upper bits of the register"}, "PEXTRW reg, xmm, imm8": {"Instruction": "PEXTRW reg, xmm, imm8", "Opcode": "66 0F C5 /r ib", "Meaning": "Extract specified word and move it to reg, setting bits 15-0 and zeroing the rest"}, "PINSRW xmm, r32/m16, imm8": {"Instruction": "PINSRW xmm, r32/m16, imm8", "Opcode": "66 0F C4 /r ib", "Meaning": "Move low word at the specified word position"}, "PACKSSDW xmm1, xmm2/m128": {"Instruction": "PACKSSDW xmm1, xmm2/m128", "Opcode": "66 0F 6B /r", "Meaning": "Converts 4 packed signed doubleword integers into 8 packed signed word integers with saturation"}, "PACKSSWB xmm1, xmm2/m128": {"Instruction": "PACKSSWB xmm1, xmm2/m128", "Opcode": "66 0F 63 /r", "Meaning": "Converts 8 packed signed word integers into 16 packed signed byte integers with saturation"}, "PACKUSWB xmm1, xmm2/m128": {"Instruction": "PACKUSWB xmm1, xmm2/m128", "Opcode": "66 0F 67 /r", "Meaning": "Converts 8 signed word integers into 16 unsigned byte integers with saturation"}, "PADDB xmm1, xmm2/m128": {"Instruction": "PADDB xmm1, xmm2/m128", "Opcode": "66 0F FC /r", "Meaning": "Add packed byte integers"}, "PADDW xmm1, xmm2/m128": {"Instruction": "PADDW xmm1, xmm2/m128", "Opcode": "66 0F FD /r", "Meaning": "Add packed word integers"}, "PADDD xmm1, xmm2/m128": {"Instruction": "PADDD xmm1, xmm2/m128", "Opcode": "66 0F FE /r", "Meaning": "Add packed doubleword integers"}, "PADDQ xmm1, xmm2/m128": {"Instruction": "PADDQ xmm1, xmm2/m128", "Opcode": "66 0F D4 /r", "Meaning": "Add packed quadword integers."}, "PADDSB xmm1, xmm2/m128": {"Instruction": "PADDSB xmm1, xmm2/m128", "Opcode": "66 0F EC /r", "Meaning": "Add packed signed byte integers with saturation"}, "PADDSW xmm1, xmm2/m128": {"Instruction": "PADDSW xmm1, xmm2/m128", "Opcode": "66 0F ED /r", "Meaning": "Add packed signed word integers with saturation"}, "PADDUSB xmm1, xmm2/m128": {"Instruction": "PADDUSB xmm1, xmm2/m128", "Opcode": "66 0F DC /r", "Meaning": "Add packed unsigned byte integers with saturation"}, "PADDUSW xmm1, xmm2/m128": {"Instruction": "PADDUSW xmm1, xmm2/m128", "Opcode": "66 0F DD /r", "Meaning": "Add packed unsigned word integers with saturation"}, "PAND xmm1, xmm2/m128": {"Instruction": "PAND xmm1, xmm2/m128", "Opcode": "66 0F DB /r", "Meaning": "Bitwise AND"}, "PANDN xmm1, xmm2/m128": {"Instruction": "PANDN xmm1, xmm2/m128", "Opcode": "66 0F DF /r", "Meaning": "Bitwise AND NOT"}, "POR xmm1, xmm2/m128": {"Instruction": "POR xmm1, xmm2/m128", "Opcode": "66 0F EB /r", "Meaning": "Bitwise OR"}, "PXOR xmm1, xmm2/m128": {"Instruction": "PXOR xmm1, xmm2/m128", "Opcode": "66 0F EF /r", "Meaning": "Bitwise XOR"}, "PCMPEQB xmm1, xmm2/m128": {"Instruction": "PCMPEQB xmm1, xmm2/m128", "Opcode": "66 0F 74 /r", "Meaning": "Compare packed bytes for equality."}, "PCMPEQW xmm1, xmm2/m128": {"Instruction": "PCMPEQW xmm1, xmm2/m128", "Opcode": "66 0F 75 /r", "Meaning": "Compare packed words for equality."}, "PCMPEQD xmm1, xmm2/m128": {"Instruction": "PCMPEQD xmm1, xmm2/m128", "Opcode": "66 0F 76 /r", "Meaning": "Compare packed doublewords for equality."}, "PCMPGTB xmm1, xmm2/m128": {"Instruction": "PCMPGTB xmm1, xmm2/m128", "Opcode": "66 0F 64 /r", "Meaning": "Compare packed signed byte integers for greater than"}, "PCMPGTW xmm1, xmm2/m128": {"Instruction": "PCMPGTW xmm1, xmm2/m128", "Opcode": "66 0F 65 /r", "Meaning": "Compare packed signed word integers for greater than"}, "PCMPGTD xmm1, xmm2/m128": {"Instruction": "PCMPGTD xmm1, xmm2/m128", "Opcode": "66 0F 66 /r", "Meaning": "Compare packed signed doubleword integers for greater than"}, "PMULLW xmm1, xmm2/m128": {"Instruction": "PMULLW xmm1, xmm2/m128", "Opcode": "66 0F D5 /r", "Meaning": "Multiply packed signed word integers with saturation"}, "PMULHW xmm1, xmm2/m128": {"Instruction": "PMULHW xmm1, xmm2/m128", "Opcode": "66 0F E5 /r", "Meaning": "Multiply the packed signed word integers, store the high 16 bits of the results"}, "PMULHUW xmm1, xmm2/m128": {"Instruction": "PMULHUW xmm1, xmm2/m128", "Opcode": "66 0F E4 /r", "Meaning": "Multiply packed unsigned word integers, store the high 16 bits of the results"}, "PMULUDQ xmm1, xmm2/m128": {"Instruction": "PMULUDQ xmm1, xmm2/m128", "Opcode": "66 0F F4 /r", "Meaning": "Multiply packed unsigned doubleword integers"}, "PSLLW xmm1, xmm2/m128": {"Instruction": "PSLLW xmm1, xmm2/m128", "Opcode": "66 0F F1 /r", "Meaning": "Shift words left while shifting in 0s"}, "PSLLW xmm1, imm8": {"Instruction": "PSLLW xmm1, imm8", "Opcode": "66 0F 71 /6 ib", "Meaning": "Shift words left while shifting in 0s"}, "PSLLD xmm1, xmm2/m128": {"Instruction": "PSLLD xmm1, xmm2/m128", "Opcode": "66 0F F2 /r", "Meaning": "Shift doublewords left while shifting in 0s"}, "PSLLD xmm1, imm8": {"Instruction": "PSLLD xmm1, imm8", "Opcode": "66 0F 72 /6 ib", "Meaning": "Shift doublewords left while shifting in 0s"}, "PSLLQ xmm1, xmm2/m128": {"Instruction": "PSLLQ xmm1, xmm2/m128", "Opcode": "66 0F F3 /r", "Meaning": "Shift quadwords left while shifting in 0s"}, "PSLLQ xmm1, imm8": {"Instruction": "PSLLQ xmm1, imm8", "Opcode": "66 0F 73 /6 ib", "Meaning": "Shift quadwords left while shifting in 0s"}, "PSRAD xmm1, xmm2/m128": {"Instruction": "PSRAD xmm1, xmm2/m128", "Opcode": "66 0F E2 /r", "Meaning": "Shift doubleword right while shifting in sign bits"}, "PSRAD xmm1, imm8": {"Instruction": "PSRAD xmm1, imm8", "Opcode": "66 0F 72 /4 ib", "Meaning": "Shift doublewords right while shifting in sign bits"}, "PSRAW xmm1, xmm2/m128": {"Instruction": "PSRAW xmm1, xmm2/m128", "Opcode": "66 0F E1 /r", "Meaning": "Shift words right while shifting in sign bits"}, "PSRAW xmm1, imm8": {"Instruction": "PSRAW xmm1, imm8", "Opcode": "66 0F 71 /4 ib", "Meaning": "Shift words right while shifting in sign bits"}, "PSRLW xmm1, xmm2/m128": {"Instruction": "PSRLW xmm1, xmm2/m128", "Opcode": "66 0F D1 /r", "Meaning": "Shift words right while shifting in 0s"}, "PSRLW xmm1, imm8": {"Instruction": "PSRLW xmm1, imm8", "Opcode": "66 0F 71 /2 ib", "Meaning": "Shift words right while shifting in 0s"}, "PSRLD xmm1, xmm2/m128": {"Instruction": "PSRLD xmm1, xmm2/m128", "Opcode": "66 0F D2 /r", "Meaning": "Shift doublewords right while shifting in 0s"}, "PSRLD xmm1, imm8": {"Instruction": "PSRLD xmm1, imm8", "Opcode": "66 0F 72 /2 ib", "Meaning": "Shift doublewords right while shifting in 0s"}, "PSRLQ xmm1, xmm2/m128": {"Instruction": "PSRLQ xmm1, xmm2/m128", "Opcode": "66 0F D3 /r", "Meaning": "Shift quadwords right while shifting in 0s"}, "PSRLQ xmm1, imm8": {"Instruction": "PSRLQ xmm1, imm8", "Opcode": "66 0F 73 /2 ib", "Meaning": "Shift quadwords right while shifting in 0s"}, "PSUBB xmm1, xmm2/m128": {"Instruction": "PSUBB xmm1, xmm2/m128", "Opcode": "66 0F F8 /r", "Meaning": "Subtract packed byte integers"}, "PSUBW xmm1, xmm2/m128": {"Instruction": "PSUBW xmm1, xmm2/m128", "Opcode": "66 0F F9 /r", "Meaning": "Subtract packed word integers"}, "PSUBD xmm1, xmm2/m128": {"Instruction": "PSUBD xmm1, xmm2/m128", "Opcode": "66 0F FA /r", "Meaning": "Subtract packed doubleword integers"}, "PSUBQ xmm1, xmm2/m128": {"Instruction": "PSUBQ xmm1, xmm2/m128", "Opcode": "66 0F FB /r", "Meaning": "Subtract packed quadword integers."}, "PSUBSB xmm1, xmm2/m128": {"Instruction": "PSUBSB xmm1, xmm2/m128", "Opcode": "66 0F E8 /r", "Meaning": "Subtract packed signed byte integers with saturation"}, "PSUBSW xmm1, xmm2/m128": {"Instruction": "PSUBSW xmm1, xmm2/m128", "Opcode": "66 0F E9 /r", "Meaning": "Subtract packed signed word integers with saturation"}, "PMADDWD xmm1, xmm2/m128": {"Instruction": "PMADDWD xmm1, xmm2/m128", "Opcode": "66 0F F5 /r", "Meaning": "Multiply the packed word integers, add adjacent doubleword results"}, "PSUBUSB xmm1, xmm2/m128": {"Instruction": "PSUBUSB xmm1, xmm2/m128", "Opcode": "66 0F D8 /r", "Meaning": "Subtract packed unsigned byte integers with saturation"}, "PSUBUSW xmm1, xmm2/m128": {"Instruction": "PSUBUSW xmm1, xmm2/m128", "Opcode": "66 0F D9 /r", "Meaning": "Subtract packed unsigned word integers with saturation"}, "PUNPCKHBW xmm1, xmm2/m128": {"Instruction": "PUNPCKHBW xmm1, xmm2/m128", "Opcode": "66 0F 68 /r", "Meaning": "Unpack and interleave high-order bytes"}, "PUNPCKHWD xmm1, xmm2/m128": {"Instruction": "PUNPCKHWD xmm1, xmm2/m128", "Opcode": "66 0F 69 /r", "Meaning": "Unpack and interleave high-order words"}, "PUNPCKHDQ xmm1, xmm2/m128": {"Instruction": "PUNPCKHDQ xmm1, xmm2/m128", "Opcode": "66 0F 6A /r", "Meaning": "Unpack and interleave high-order doublewords"}, "PUNPCKLBW xmm1, xmm2/m128": {"Instruction": "PUNPCKLBW xmm1, xmm2/m128", "Opcode": "66 0F 60 /r", "Meaning": "Interleave low-order bytes"}, "PUNPCKLWD xmm1, xmm2/m128": {"Instruction": "PUNPCKLWD xmm1, xmm2/m128", "Opcode": "66 0F 61 /r", "Meaning": "Interleave low-order words"}, "PUNPCKLDQ xmm1, xmm2/m128": {"Instruction": "PUNPCKLDQ xmm1, xmm2/m128", "Opcode": "66 0F 62 /r", "Meaning": "Interleave low-order doublewords"}, "PAVGB xmm1, xmm2/m128": {"Instruction": "PAVGB xmm1, xmm2/m128", "Opcode": "66 0F E0, /r", "Meaning": "Average packed unsigned byte integers with rounding"}, "PAVGW xmm1, xmm2/m128": {"Instruction": "PAVGW xmm1, xmm2/m128", "Opcode": "66 0F E3 /r", "Meaning": "Average packed unsigned word integers with rounding"}, "PMINUB xmm1, xmm2/m128": {"Instruction": "PMINUB xmm1, xmm2/m128", "Opcode": "66 0F DA /r", "Meaning": "Compare packed unsigned byte integers and store packed minimum values"}, "PMINSW xmm1, xmm2/m128": {"Instruction": "PMINSW xmm1, xmm2/m128", "Opcode": "66 0F EA /r", "Meaning": "Compare packed signed word integers and store packed minimum values"}, "PMAXSW xmm1, xmm2/m128": {"Instruction": "PMAXSW xmm1, xmm2/m128", "Opcode": "66 0F EE /r", "Meaning": "Compare packed signed word integers and store maximum packed values"}, "PMAXUB xmm1, xmm2/m128": {"Instruction": "PMAXUB xmm1, xmm2/m128", "Opcode": "66 0F DE /r", "Meaning": "Compare packed unsigned byte integers and store packed maximum values"}, "PSADBW xmm1, xmm2/m128": {"Instruction": "PSADBW xmm1, xmm2/m128", "Opcode": "66 0F F6 /r", "Meaning": "Computes the absolute differences of the packed unsigned byte integers; the 8 low differences and 8 high differences are then summed separately to produce two unsigned word integer results"}, "MASKMOVDQU xmm1, xmm2": {"Instruction": "MASKMOVDQU xmm1, xmm2", "Opcode": "66 0F F7 /r", "Meaning": "Non-Temporal Store of Selected Bytes from an XMM Register into Memory"}, "MOVDQ2Q mm, xmm": {"Instruction": "MOVDQ2Q mm, xmm", "Opcode": "F2 0F D6 /r", "Meaning": "Move low quadword from XMM to MMX register."}, "MOVDQA xmm1, xmm2/m128": {"Instruction": "MOVDQA xmm1, xmm2/m128", "Opcode": "66 0F 6F /r", "Meaning": "Move aligned double quadword"}, "MOVDQA xmm2/m128, xmm1": {"Instruction": "MOVDQA xmm2/m128, xmm1", "Opcode": "66 0F 7F /r", "Meaning": "Move aligned double quadword"}, "MOVDQU xmm1, xmm2/m128": {"Instruction": "MOVDQU xmm1, xmm2/m128", "Opcode": "F3 0F 6F /r", "Meaning": "Move unaligned double quadword"}, "MOVDQU xmm2/m128, xmm1": {"Instruction": "MOVDQU xmm2/m128, xmm1", "Opcode": "F3 0F 7F /r", "Meaning": "Move unaligned double quadword"}, "MOVQ2DQ xmm, mm": {"Instruction": "MOVQ2DQ xmm, mm", "Opcode": "F3 0F D6 /r", "Meaning": "Move quadword from MMX register to low quadword of XMM register"}, "MOVNTDQ m128, xmm1": {"Instruction": "MOVNTDQ m128, xmm1", "Opcode": "66 0F E7 /r", "Meaning": "Store Packed Integers Using Non-Temporal Hint"}, "PSHUFHW xmm1, xmm2/m128, imm8": {"Instruction": "PSHUFHW xmm1, xmm2/m128, imm8", "Opcode": "F3 0F 70 /r ib", "Meaning": "Shuffle packed high words."}, "PSHUFLW xmm1, xmm2/m128, imm8": {"Instruction": "PSHUFLW xmm1, xmm2/m128, imm8", "Opcode": "F2 0F 70 /r ib", "Meaning": "Shuffle packed low words."}, "PSHUFD xmm1, xmm2/m128, imm8": {"Instruction": "PSHUFD xmm1, xmm2/m128, imm8", "Opcode": "66 0F 70 /r ib", "Meaning": "Shuffle packed doublewords."}, "PSLLDQ xmm1, imm8": {"Instruction": "PSLLDQ xmm1, imm8", "Opcode": "66 0F 73 /7 ib", "Meaning": "Packed shift left logical double quadwords."}, "PSRLDQ xmm1, imm8": {"Instruction": "PSRLDQ xmm1, imm8", "Opcode": "66 0F 73 /3 ib", "Meaning": "Packed shift right logical double quadwords."}, "PUNPCKHQDQ xmm1, xmm2/m128": {"Instruction": "PUNPCKHQDQ xmm1, xmm2/m128", "Opcode": "66 0F 6D /r", "Meaning": "Unpack and interleave high-order quadwords,"}, "PUNPCKLQDQ xmm1, xmm2/m128": {"Instruction": "PUNPCKLQDQ xmm1, xmm2/m128", "Opcode": "66 0F 6C /r", "Meaning": "Interleave low quadwords,"}, "ADDSUBPS xmm1, xmm2/m128": {"Instruction": "ADDSUBPS xmm1, xmm2/m128", "Opcode": "F2 0F D0 /r", "Meaning": "Add/subtract single-precision floating-point values", "Notes": "for Complex Arithmetic"}, "HADDPS xmm1, xmm2/m128": {"Instruction": "HADDPS xmm1, xmm2/m128", "Opcode": "F2 0F 7C /r", "Meaning": "Horizontal add packed single-precision floating-point values", "Notes": "for Graphics"}, "LDDQU xmm1, mem": {"Instruction": "LDDQU xmm1, mem", "Opcode": "F2 0F F0 /r", "Meaning": "Load unaligned data and return double quadword", "Notes": "Instructionally equivalent to MOVDQU. For video encoding"}, "PSIGNB xmm1, xmm2/m128": {"Instruction": "PSIGNB xmm1, xmm2/m128", "Opcode": "66 0F 38 08 /r", "Meaning": "Negate/zero/preserve packed byte integers depending on corresponding sign"}, "PSIGNW xmm1, xmm2/m128": {"Instruction": "PSIGNW xmm1, xmm2/m128", "Opcode": "66 0F 38 09 /r", "Meaning": "Negate/zero/preserve packed word integers depending on corresponding sign"}, "PSIGND xmm1, xmm2/m128": {"Instruction": "PSIGND xmm1, xmm2/m128", "Opcode": "66 0F 38 0A /r", "Meaning": "Negate/zero/preserve packed doubleword integers depending on corresponding"}, "PSHUFB xmm1, xmm2/m128": {"Instruction": "PSHUFB xmm1, xmm2/m128", "Opcode": "66 0F 38 00 /r", "Meaning": "Shuffle bytes"}, "PMULHRSW xmm1, xmm2/m128": {"Instruction": "PMULHRSW xmm1, xmm2/m128", "Opcode": "66 0F 38 0B /r", "Meaning": "Multiply 16-bit signed words, scale and round signed doublewords, pack high 16 bits"}, "PMADDUBSW xmm1, xmm2/m128": {"Instruction": "PMADDUBSW xmm1, xmm2/m128", "Opcode": "66 0F 38 04 /r", "Meaning": "Multiply signed and unsigned bytes, add horizontal pair of signed words, pack saturated signed-words"}, "PHSUBW xmm1, xmm2/m128": {"Instruction": "PHSUBW xmm1, xmm2/m128", "Opcode": "66 0F 38 05 /r", "Meaning": "Subtract and pack 16-bit signed integers horizontally"}, "PHSUBSW xmm1, xmm2/m128": {"Instruction": "PHSUBSW xmm1, xmm2/m128", "Opcode": "66 0F 38 07 /r", "Meaning": "Subtract and pack 16-bit signed integer horizontally with saturation"}, "PHSUBD xmm1, xmm2/m128": {"Instruction": "PHSUBD xmm1, xmm2/m128", "Opcode": "66 0F 38 06 /r", "Meaning": "Subtract and pack 32-bit signed integers horizontally"}, "PHADDSW xmm1, xmm2/m128": {"Instruction": "PHADDSW xmm1, xmm2/m128", "Opcode": "66 0F 38 03 /r", "Meaning": "Add and pack 16-bit signed integers horizontally with saturation"}, "PHADDW xmm1, xmm2/m128": {"Instruction": "PHADDW xmm1, xmm2/m128", "Opcode": "66 0F 38 01 /r", "Meaning": "Add and pack 16-bit integers horizontally"}, "PHADDD xmm1, xmm2/m128": {"Instruction": "PHADDD xmm1, xmm2/m128", "Opcode": "66 0F 38 02 /r", "Meaning": "Add and pack 32-bit integers horizontally"}, "PALIGNR xmm1, xmm2/m128, imm8": {"Instruction": "PALIGNR xmm1, xmm2/m128, imm8", "Opcode": "66 0F 3A 0F /r ib", "Meaning": "Concatenate destination and source operands, extract byte-aligned result shifted to the right"}, "PABSB xmm1, xmm2/m128": {"Instruction": "PABSB xmm1, xmm2/m128", "Opcode": "66 0F 38 1C /r", "Meaning": "Compute the absolute value of bytes and store unsigned result"}, "PABSW xmm1, xmm2/m128": {"Instruction": "PABSW xmm1, xmm2/m128", "Opcode": "66 0F 38 1D /r", "Meaning": "Compute the absolute value of 16-bit integers and store unsigned result"}, "PABSD xmm1, xmm2/m128": {"Instruction": "PABSD xmm1, xmm2/m128", "Opcode": "66 0F 38 1E /r", "Meaning": "Compute the absolute value of 32-bit integers and store unsigned result"}, "DPPS xmm1, xmm2/m128, imm8": {"Instruction": "DPPS xmm1, xmm2/m128, imm8", "Opcode": "66 0F 3A 40 /r ib", "Meaning": "Selectively multiply packed SP floating-point values, add and selectively store"}, "DPPD xmm1, xmm2/m128, imm8": {"Instruction": "DPPD xmm1, xmm2/m128, imm8", "Opcode": "66 0F 3A 41 /r ib", "Meaning": "Selectively multiply packed DP floating-point values, add and selectively store"}, "BLENDPS xmm1, xmm2/m128, imm8": {"Instruction": "BLENDPS xmm1, xmm2/m128, imm8", "Opcode": "66 0F 3A 0C /r ib", "Meaning": "Select packed single precision floating-point values from specified mask"}, "BLENDVPS xmm1, xmm2/m128, <XMM0>": {"Instruction": "BLENDVPS xmm1, xmm2/m128, <XMM0>", "Opcode": "66 0F 38 14 /r", "Meaning": "Select packed single precision floating-point values from specified mask"}, "BLENDPD xmm1, xmm2/m128, imm8": {"Instruction": "BLENDPD xmm1, xmm2/m128, imm8", "Opcode": "66 0F 3A 0D /r ib", "Meaning": "Select packed DP-FP values from specified mask"}, "BLENDVPD xmm1, xmm2/m128 , <XMM0>": {"Instruction": "BLENDVPD xmm1, xmm2/m128 , <XMM0>", "Opcode": "66 0F 38 15 /r", "Meaning": "Select packed DP FP values from specified mask"}, "ROUNDPS xmm1, xmm2/m128, imm8": {"Instruction": "ROUNDPS xmm1, xmm2/m128, imm8", "Opcode": "66 0F 3A 08 /r ib", "Meaning": "Round packed single precision floating-point values"}, "ROUNDSS xmm1, xmm2/m32, imm8": {"Instruction": "ROUNDSS xmm1, xmm2/m32, imm8", "Opcode": "66 0F 3A 0A /r ib", "Meaning": "Round the low packed single precision floating-point value"}, "ROUNDPD xmm1, xmm2/m128, imm8": {"Instruction": "ROUNDPD xmm1, xmm2/m128, imm8", "Opcode": "66 0F 3A 09 /r ib", "Meaning": "Round packed double precision floating-point values"}, "ROUNDSD xmm1, xmm2/m64, imm8": {"Instruction": "ROUNDSD xmm1, xmm2/m64, imm8", "Opcode": "66 0F 3A 0B /r ib", "Meaning": "Round the low packed double precision floating-point value"}, "INSERTPS xmm1, xmm2/m32, imm8": {"Instruction": "INSERTPS xmm1, xmm2/m32, imm8", "Opcode": "66 0F 3A 21 /r ib", "Meaning": "Insert a selected single-precision floating-point value at the specified destination element and zero out destination elements"}, "EXTRACTPS reg/m32, xmm1, imm8": {"Instruction": "EXTRACTPS reg/m32, xmm1, imm8", "Opcode": "66 0F 3A 17 /r ib", "Meaning": "Extract one single-precision floating-point value at specified offset and store the result (zero-extended, if applicable)"}, "MPSADBW xmm1, xmm2/m128, imm8": {"Instruction": "MPSADBW xmm1, xmm2/m128, imm8", "Opcode": "66 0F 3A 42 /r ib", "Meaning": "Sums absolute 8-bit integer difference of adjacent groups of 4 byte integers with starting offset"}, "PHMINPOSUW xmm1, xmm2/m128": {"Instruction": "PHMINPOSUW xmm1, xmm2/m128", "Opcode": "66 0F 38 41 /r", "Meaning": "Find the minimum unsigned word"}, "PMULLD xmm1, xmm2/m128": {"Instruction": "PMULLD xmm1, xmm2/m128", "Opcode": "66 0F 38 40 /r", "Meaning": "Multiply the packed dword signed integers and store the low 32 bits"}, "PMULDQ xmm1, xmm2/m128": {"Instruction": "PMULDQ xmm1, xmm2/m128", "Opcode": "66 0F 38 28 /r", "Meaning": "Multiply packed signed doubleword integers and store quadword result"}, "PBLENDVB xmm1, xmm2/m128, <XMM0>": {"Instruction": "PBLENDVB xmm1, xmm2/m128, <XMM0>", "Opcode": "66 0F 38 10 /r", "Meaning": "Select byte values from specified mask"}, "PBLENDW xmm1, xmm2/m128, imm8": {"Instruction": "PBLENDW xmm1, xmm2/m128, imm8", "Opcode": "66 0F 3A 0E /r ib", "Meaning": "Select words from specified mask"}, "PMINSB xmm1, xmm2/m128": {"Instruction": "PMINSB xmm1, xmm2/m128", "Opcode": "66 0F 38 38 /r", "Meaning": "Compare packed signed byte integers"}, "PMINUW xmm1, xmm2/m128": {"Instruction": "PMINUW xmm1, xmm2/m128", "Opcode": "66 0F 38 3A/r", "Meaning": "Compare packed unsigned word integers"}, "PMINSD xmm1, xmm2/m128": {"Instruction": "PMINSD xmm1, xmm2/m128", "Opcode": "66 0F 38 39 /r", "Meaning": "Compare packed signed dword integers"}, "PMINUD xmm1, xmm2/m128": {"Instruction": "PMINUD xmm1, xmm2/m128", "Opcode": "66 0F 38 3B /r", "Meaning": "Compare packed unsigned dword integers"}, "PMAXSB xmm1, xmm2/m128": {"Instruction": "PMAXSB xmm1, xmm2/m128", "Opcode": "66 0F 38 3C /r", "Meaning": "Compare packed signed byte integers"}, "PMAXUW xmm1, xmm2/m128": {"Instruction": "PMAXUW xmm1, xmm2/m128", "Opcode": "66 0F 38 3E/r", "Meaning": "Compare packed unsigned word integers"}, "PMAXSD xmm1, xmm2/m128": {"Instruction": "PMAXSD xmm1, xmm2/m128", "Opcode": "66 0F 38 3D /r", "Meaning": "Compare packed signed dword integers"}, "PMAXUD xmm1, xmm2/m128": {"Instruction": "PMAXUD xmm1, xmm2/m128", "Opcode": "66 0F 38 3F /r", "Meaning": "Compare packed unsigned dword integers"}, "PINSRB xmm1, r32/m8, imm8": {"Instruction": "PINSRB xmm1, r32/m8, imm8", "Opcode": "66 0F 3A 20 /r ib", "Meaning": "Insert a byte integer value at specified destination element"}, "PINSRD xmm1, r/m32, imm8": {"Instruction": "PINSRD xmm1, r/m32, imm8", "Opcode": "66 0F 3A 22 /r ib", "Meaning": "Insert a dword integer value at specified destination element"}, "PINSRQ xmm1, r/m64, imm8": {"Instruction": "PINSRQ xmm1, r/m64, imm8", "Opcode": "66 REX.W 0F 3A 22 /r ib", "Meaning": "Insert a qword integer value at specified destination element"}, "PEXTRB reg/m8, xmm2, imm8": {"Instruction": "PEXTRB reg/m8, xmm2, imm8", "Opcode": "66 0F 3A 14 /r ib", "Meaning": "Extract a byte integer value at source byte offset, upper bits are zeroed."}, "PEXTRW reg/m16, xmm, imm8": {"Instruction": "PEXTRW reg/m16, xmm, imm8", "Opcode": "66 0F 3A 15 /r ib", "Meaning": "Extract word and copy to lowest 16 bits, zero-extended"}, "PEXTRD r/m32, xmm2, imm8": {"Instruction": "PEXTRD r/m32, xmm2, imm8", "Opcode": "66 0F 3A 16 /r ib", "Meaning": "Extract a dword integer value at source dword offset"}, "PEXTRQ r/m64, xmm2, imm8": {"Instruction": "PEXTRQ r/m64, xmm2, imm8", "Opcode": "66 REX.W 0F 3A 16 /r ib", "Meaning": "Extract a qword integer value at source qword offset"}, "PMOVSXBW xmm1, xmm2/m64": {"Instruction": "PMOVSXBW xmm1, xmm2/m64", "Opcode": "66 0f 38 20 /r", "Meaning": "Sign extend 8 packed 8-bit integers to 8 packed 16-bit integers"}, "PMOVZXBW xmm1, xmm2/m64": {"Instruction": "PMOVZXBW xmm1, xmm2/m64", "Opcode": "66 0f 38 30 /r", "Meaning": "Zero extend 8 packed 8-bit integers to 8 packed 16-bit integers"}, "PMOVSXBD xmm1, xmm2/m32": {"Instruction": "PMOVSXBD xmm1, xmm2/m32", "Opcode": "66 0f 38 21 /r", "Meaning": "Sign extend 4 packed 8-bit integers to 4 packed 32-bit integers"}, "PMOVZXBD xmm1, xmm2/m32": {"Instruction": "PMOVZXBD xmm1, xmm2/m32", "Opcode": "66 0f 38 31 /r", "Meaning": "Zero extend 4 packed 8-bit integers to 4 packed 32-bit integers"}, "PMOVSXBQ xmm1, xmm2/m16": {"Instruction": "PMOVSXBQ xmm1, xmm2/m16", "Opcode": "66 0f 38 22 /r", "Meaning": "Sign extend 2 packed 8-bit integers to 2 packed 64-bit integers"}, "PMOVZXBQ xmm1, xmm2/m16": {"Instruction": "PMOVZXBQ xmm1, xmm2/m16", "Opcode": "66 0f 38 32 /r", "Meaning": "Zero extend 2 packed 8-bit integers to 2 packed 64-bit integers"}, "PMOVSXWD xmm1, xmm2/m64": {"Instruction": "PMOVSXWD xmm1, xmm2/m64", "Opcode": "66 0f 38 23/r", "Meaning": "Sign extend 4 packed 16-bit integers to 4 packed 32-bit integers"}, "PMOVZXWD xmm1, xmm2/m64": {"Instruction": "PMOVZXWD xmm1, xmm2/m64", "Opcode": "66 0f 38 33 /r", "Meaning": "Zero extend 4 packed 16-bit integers to 4 packed 32-bit integers"}, "PMOVSXWQ xmm1, xmm2/m32": {"Instruction": "PMOVSXWQ xmm1, xmm2/m32", "Opcode": "66 0f 38 24 /r", "Meaning": "Sign extend 2 packed 16-bit integers to 2 packed 64-bit integers"}, "PMOVZXWQ xmm1, xmm2/m32": {"Instruction": "PMOVZXWQ xmm1, xmm2/m32", "Opcode": "66 0f 38 34 /r", "Meaning": "Zero extend 2 packed 16-bit integers to 2 packed 64-bit integers"}, "PMOVSXDQ xmm1, xmm2/m64": {"Instruction": "PMOVSXDQ xmm1, xmm2/m64", "Opcode": "66 0f 38 25 /r", "Meaning": "Sign extend 2 packed 32-bit integers to 2 packed 64-bit integers"}, "PMOVZXDQ xmm1, xmm2/m64": {"Instruction": "PMOVZXDQ xmm1, xmm2/m64", "Opcode": "66 0f 38 35 /r", "Meaning": "Zero extend 2 packed 32-bit integers to 2 packed 64-bit integers"}, "PTEST xmm1, xmm2/m128": {"Instruction": "PTEST xmm1, xmm2/m128", "Opcode": "66 0F 38 17 /r", "Meaning": "Set ZF if AND result is all 0s, set CF if AND NOT result is all 0s"}, "PCMPEQQ xmm1, xmm2/m128": {"Instruction": "PCMPEQQ xmm1, xmm2/m128", "Opcode": "66 0F 38 29 /r", "Meaning": "Compare packed qwords for equality"}, "PACKUSDW xmm1, xmm2/m128": {"Instruction": "PACKUSDW xmm1, xmm2/m128", "Opcode": "66 0F 38 2B /r", "Meaning": "Convert 2 \u00d7 4 packed signed doubleword integers into 8 packed unsigned word integers with saturation"}, "MOVNTDQA xmm1, m128": {"Instruction": "MOVNTDQA xmm1, m128", "Opcode": "66 0F 38 2A /r", "Meaning": "Move double quadword using non-temporal hint if WC memory type"}, "PCMPESTRI xmm1, xmm2/m128, imm8": {"Instruction": "PCMPESTRI xmm1, xmm2/m128, imm8", "Opcode": "66 0F 3A 61 /r imm8", "Meaning": "Packed comparison of string data with explicit lengths, generating an index"}, "PCMPESTRM xmm1, xmm2/m128, imm8": {"Instruction": "PCMPESTRM xmm1, xmm2/m128, imm8", "Opcode": "66 0F 3A 60 /r imm8", "Meaning": "Packed comparison of string data with explicit lengths, generating a mask"}, "PCMPISTRI xmm1, xmm2/m128, imm8": {"Instruction": "PCMPISTRI xmm1, xmm2/m128, imm8", "Opcode": "66 0F 3A 63 /r imm8", "Meaning": "Packed comparison of string data with implicit lengths, generating an index"}, "PCMPISTRM xmm1, xmm2/m128, imm8": {"Instruction": "PCMPISTRM xmm1, xmm2/m128, imm8", "Opcode": "66 0F 3A 62 /r imm8", "Meaning": "Packed comparison of string data with implicit lengths, generating a mask"}, "PCMPGTQ xmm1,xmm2/m128": {"Instruction": "PCMPGTQ xmm1,xmm2/m128", "Opcode": "66 0F 38 37 /r", "Meaning": "Compare packed signed qwords for greater than."}, "VFMADDPD xmm0, xmm1, xmm2, xmm3": {"Instruction": "VFMADDPD xmm0, xmm1, xmm2, xmm3", "Opcode": "C4E3 WvvvvL01 69 /r /is4", "Meaning": "Fused Multiply-Add of Packed Double-Precision Floating-Point Values", "Notes": None}, "VFMADDPS xmm0, xmm1, xmm2, xmm3": {"Instruction": "VFMADDPS xmm0, xmm1, xmm2, xmm3", "Opcode": "C4E3 WvvvvL01 68 /r /is4", "Meaning": "Fused Multiply-Add of Packed Single-Precision Floating-Point Values", "Notes": None}, "VFMADDSD xmm0, xmm1, xmm2, xmm3": {"Instruction": "VFMADDSD xmm0, xmm1, xmm2, xmm3", "Opcode": "C4E3 WvvvvL01 6B /r /is4", "Meaning": "Fused Multiply-Add of Scalar Double-Precision Floating-Point Values", "Notes": None}, "VFMADDSS xmm0, xmm1, xmm2, xmm3": {"Instruction": "VFMADDSS xmm0, xmm1, xmm2, xmm3", "Opcode": "C4E3 WvvvvL01 6A /r /is4", "Meaning": "Fused Multiply-Add of Scalar Single-Precision Floating-Point Values", "Notes": None}, "VFMADDSUBPD xmm0, xmm1, xmm2, xmm3": {"Instruction": "VFMADDSUBPD xmm0, xmm1, xmm2, xmm3", "Opcode": "C4E3 WvvvvL01 5D /r /is4", "Meaning": "Fused Multiply-Alternating Add/Subtract of Packed Double-Precision Floating-Point Values", "Notes": None}, "VFMADDSUBPS xmm0, xmm1, xmm2, xmm3": {"Instruction": "VFMADDSUBPS xmm0, xmm1, xmm2, xmm3", "Opcode": "C4E3 WvvvvL01 5C /r /is4", "Meaning": "Fused Multiply-Alternating Add/Subtract of Packed Single-Precision Floating-Point Values", "Notes": None}, "VFMSUBADDPD xmm0, xmm1, xmm2, xmm3": {"Instruction": "VFMSUBADDPD xmm0, xmm1, xmm2, xmm3", "Opcode": "C4E3 WvvvvL01 5F /r /is4", "Meaning": "Fused Multiply-Alternating Subtract/Add of Packed Double-Precision Floating-Point Values", "Notes": None}, "VFMSUBADDPS xmm0, xmm1, xmm2, xmm3": {"Instruction": "VFMSUBADDPS xmm0, xmm1, xmm2, xmm3", "Opcode": "C4E3 WvvvvL01 5E /r /is4", "Meaning": "Fused Multiply-Alternating Subtract/Add of Packed Single-Precision Floating-Point Values", "Notes": None}, "VFMSUBPD xmm0, xmm1, xmm2, xmm3": {"Instruction": "VFMSUBPD xmm0, xmm1, xmm2, xmm3", "Opcode": "C4E3 WvvvvL01 6D /r /is4", "Meaning": "Fused Multiply-Subtract of Packed Double-Precision Floating-Point Values", "Notes": None}, "VFMSUBPS xmm0, xmm1, xmm2, xmm3": {"Instruction": "VFMSUBPS xmm0, xmm1, xmm2, xmm3", "Opcode": "C4E3 WvvvvL01 6C /r /is4", "Meaning": "Fused Multiply-Subtract of Packed Single-Precision Floating-Point Values", "Notes": None}, "VFMSUBSD xmm0, xmm1, xmm2, xmm3": {"Instruction": "VFMSUBSD xmm0, xmm1, xmm2, xmm3", "Opcode": "C4E3 WvvvvL01 6F /r /is4", "Meaning": "Fused Multiply-Subtract of Scalar Double-Precision Floating-Point Values", "Notes": None}, "VFMSUBSS xmm0, xmm1, xmm2, xmm3": {"Instruction": "VFMSUBSS xmm0, xmm1, xmm2, xmm3", "Opcode": "C4E3 WvvvvL01 6E /r /is4", "Meaning": "Fused Multiply-Subtract of Scalar Single-Precision Floating-Point Values", "Notes": None}, "VFNMADDPD xmm0, xmm1, xmm2, xmm3": {"Instruction": "VFNMADDPD xmm0, xmm1, xmm2, xmm3", "Opcode": "C4E3 WvvvvL01 79 /r /is4", "Meaning": "Fused Negative Multiply-Add of Packed Double-Precision Floating-Point Values", "Notes": None}, "VFNMADDPS xmm0, xmm1, xmm2, xmm3": {"Instruction": "VFNMADDPS xmm0, xmm1, xmm2, xmm3", "Opcode": "C4E3 WvvvvL01 78 /r /is4", "Meaning": "Fused Negative Multiply-Add of Packed Single-Precision Floating-Point Values", "Notes": None}, "VFNMADDSD xmm0, xmm1, xmm2, xmm3": {"Instruction": "VFNMADDSD xmm0, xmm1, xmm2, xmm3", "Opcode": "C4E3 WvvvvL01 7B /r /is4", "Meaning": "Fused Negative Multiply-Add of Scalar Double-Precision Floating-Point Values", "Notes": None}, "VFNMADDSS xmm0, xmm1, xmm2, xmm3": {"Instruction": "VFNMADDSS xmm0, xmm1, xmm2, xmm3", "Opcode": "C4E3 WvvvvL01 7A /r /is4", "Meaning": "Fused Negative Multiply-Add of Scalar Single-Precision Floating-Point Values", "Notes": None}, "VFNMSUBPD xmm0, xmm1, xmm2, xmm3": {"Instruction": "VFNMSUBPD xmm0, xmm1, xmm2, xmm3", "Opcode": "C4E3 WvvvvL01 7D /r /is4", "Meaning": "Fused Negative Multiply-Subtract of Packed Double-Precision Floating-Point Values", "Notes": None}, "VFNMSUBPS xmm0, xmm1, xmm2, xmm3": {"Instruction": "VFNMSUBPS xmm0, xmm1, xmm2, xmm3", "Opcode": "C4E3 WvvvvL01 7C /r /is4", "Meaning": "Fused Negative Multiply-Subtract of Packed Single-Precision Floating-Point Values", "Notes": None}, "VFNMSUBSD xmm0, xmm1, xmm2, xmm3": {"Instruction": "VFNMSUBSD xmm0, xmm1, xmm2, xmm3", "Opcode": "C4E3 WvvvvL01 7F /r /is4", "Meaning": "Fused Negative Multiply-Subtract of Scalar Double-Precision Floating-Point Values", "Notes": None}, "VFNMSUBSS xmm0, xmm1, xmm2, xmm3": {"Instruction": "VFNMSUBSS xmm0, xmm1, xmm2, xmm3", "Opcode": "C4E3 WvvvvL01 7E /r /is4", "Meaning": "Fused Negative Multiply-Subtract of Scalar Single-Precision Floating-Point Values", "Notes": None}}
instruction_list = list(data_dict.keys())


def is_instruction(token):
    for x, instruction in enumerate(instruction_list):
        if token.upper() == instruction.split()[0].upper():
            return True, x
        else:
            continue
    return False, 0


def stringForToken(token):
    if token.upper() in "JA, JAE, JB, JBE, JC, JE, JG, JGE, JL, JLE, JNA, JNAE, JNB, JNBE, JNC, JNE, JNG, JNGE, JNL, JNLE, JNO, JNP, JNS, JNZ, JO, JP, JPE, JPO, JS, JZ":
        token="Jcc"
    if token.upper() in "REP, REPE, REPNE, REPNZ, REPZ":
        token="REPxx"
    if token.upper() in "SETA, SETAE, SETB, SETBE, SETC, SETE, SETG, SETGE, SETL, SETLE, SETNA, SETNAE, SETNB, SETNBE, SETNC, SETNE, SETNG, SETNGE, SETNL, SETNLE, SETNO, SETNP, SETNS, SETNZ, SETO, SETP, SETPE, SETPO, SETS, SETZ":
        token="SETcc"
    if token+",".upper() in "CMOVA, CMOVAE, CMOVB, CMOVBE, CMOVC, CMOVE, CMOVG, CMOVGE, CMOVL, CMOVLE, CMOVNA, CMOVNAE, CMOVNB, CMOVNBE, CMOVNC, CMOVNE, CMOVNG, CMOVNGE, CMOVNL, CMOVNLE, CMOVNO, CMOVNP, CMOVNS, CMOVNZ, CMOVO, CMOVP, CMOVPE, CMOVPO, CMOVS, CMOVZ,":
        token="CMOVcc"
    isinst, x = is_instruction(token)
    if isinst:
        retval = "<h1>"+token + " : </h1>"
        inst_data = data_dict[instruction_list[x]]
        for key, value in inst_data.items():
            if key != "Instruction":
                if key and value:
                    retval = retval + "<b>"+key + "</b> : <tt>" + value + "</tt><br>"
        return retval+"<hr>"
    else:
        return ""

def stringForTokens(tokens):
    retval=""
    for token in tokens:
        retval=retval+stringForToken(token)
    return retval

class MyDockWidget(cutter.CutterDockWidget):
    def __init__(self, parent, action):
        super(MyDockWidget, self).__init__(parent, action)
        self.setObjectName("asm_ref")
        self.setWindowTitle("Assembly Refrence")

        self.view = QTextEdit(self)
        self.view.setReadOnly(True)
        self.setWidget(self.view)

        QObject.connect(cutter.core(), SIGNAL("seekChanged(RVA)"), self.update_contents)
        self.update_contents()

    def update_contents(self):
            instructions = cutter.cmdj("pdj 1")
            try:
                tokens = instructions[0]["disasm"].split()
                self.view.setHtml(stringForTokens(tokens))
            except:
                self.view.setHtml("NO instruction found on current line")
            


class MyCutterPlugin(cutter.CutterPlugin):
    name = "Assembly refrence"
    description = "Shows refrence of assembly instruction"
    version = "1.0"
    author = "Daring Joker"

    def setupPlugin(self):
        pass

    def setupInterface(self, main):
        action = QAction("Assembly refrence", main)
        action.setCheckable(True)
        widget = MyDockWidget(main, action)
        main.addPluginDockWidget(widget, action)

    def terminate(self):
        pass


def create_cutter_plugin():
    return MyCutterPlugin()
